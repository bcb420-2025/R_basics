[["about.html", "BCB420 - Computational System Biology R - Basics Chapter 1 About 1.1 Attributions:", " BCB420 - Computational System Biology R - Basics Main author: Boris Steipe; Modified: Ruth Isserlin last modified 2025-01-02 Chapter 1 About Original content for this book was created by Boris Steipe from Boris Steipe BCB420 wiki resources licensed under CC BY 4.0. 1.1 Attributions: This book was created using The bookdown package and can be installed from CRAN or Github: install.packages(&quot;bookdown&quot;) # or the development version # devtools::install_github(&quot;rstudio/bookdown&quot;) Icons are from the “Very Basic. Android L Lollipop” set by Ivan Boyko licensed under CC BY 3.0. "],["r_install.html", "Chapter 2 Installing R and RStudio 2.1 Overview 2.2 R 2.3 The environment 2.4 Task 1 - Install R 2.5 Task 2 - Install RStudio 2.6 Docker 2.7 Docker - Basic term definition 2.8 Task 3 - Install Docker 2.9 Task 4 - Create your first notebook using Docker 2.10 Packages 2.11 Task 5 - Experiment with RStudio and packages", " Chapter 2 Installing R and RStudio (Notation; installing R and RStudio; packages; first experiments.) 2.1 Overview ###Abstract: This unit works through the installation of R and RStudio on your machine as well as through docker and introduces R’s packages of additional functions. 2.1.1 Objectives: This unit will: guide you through first steps for installing R and R Studio on your own computer; and guide you through installing and using R and R Studio through docker; and introduce the concept of “packages” to extend R’s functionality; 2.1.2 Outcomes: After working through this unit you: have a working installation of R and RStudio and know how to start RStudio; have a working knowledge of docker and how to use it with R and Rstudio. can find and install packages. 2.1.3 Deliverables: Time management: Before you begin, estimate how long it will take you to complete this unit. Then, record in your course journal: the number of hours you estimated, the number of hours you worked on the unit, and the amount of time that passed between start and completion of this unit. Journal: Document your progress in your Course Journal. Some tasks may ask you to include specific items in your journal. Don’t overlook these. Insights: If you find something particularly noteworthy about this unit, make a note in your insights! page. 2.1.4 Prerequisites: This unit builds on material covered in the following prerequisite units: 2.2 R 2.2.1 Introduction The R statistics environment and programming language is an exceptionally well engineered, free (as in free speech) and free (as in free beer) platform for data manipulation and analysis. The number of functions that are included by default is large, there is a very large number of additional, community-generated analysis modules that can be simply imported from dedicated sites (e.g. the Bioconductor project for molecular biology data), or via the CRAN network, and whatever function is not available can be easily programmed. The ability to filter and manipulate data to prepare it for analysis is an absolute requirement in research-centric fields such as ours, where the strategies for analysis are constantly shifting and prepackaged solutions become obsolete almost faster than they can be developed. Besides numerical analysis, R has very powerful and flexible functions for plotting graphical output. Note: you can’t learn a programming language in a single day. Work through this material unit by unit, but when you are done, you need constant repetition to bring it into active memory. And make sure you understand every step. Taking shortcuts and/or cramming everything in a single, desperate effort is a waste of your time. 2.2.2 Before you begin: Notation and Formatting In this tutorial, I use specific notation and formatting to mean different things: If you see footnotes1, click on the number to read more. This is normal text for explanations. It is written in a proportionally spaced font. Code formatting is for code examples, file- and function names, directory paths etc. Code is written in a monospaced font2. for (i in 1:10){ #example code block } Bold emphasis and underlining are to mark words as particularly important. Examples of the right way to do something are highlighted green. Examples of the wrong way to do something are highlighted red. 2.2.3 Task - example Tasks and exercises are described in boxes with a blue background. It is highly recommended that you do them. You won’t be graded on them but they are all content you can add to your journal. If you have problems, you must contact your instructor, or discuss the issue on the mailing list. Don’t simply continue. All material builds on previous material, and evaluation is cumulative. These sections have information about issues I encounter more frequently. They are required reading when you need to troubleshoot problems but also give background information that may be useful to avoid problems in the first place. 2.2.4 “Metasyntactic variables” When I use notation like &lt;Year&gt; in instructions, you type the year, the whole year and nothing but the year (e.g the four digits 2017). You never type the angle brackets! I use the angle brackets only to indicate that you should not type Year literally, but substitute the correct value. You might encounter this notation as &lt;path&gt;, &lt;filename&gt;, &lt;firstname lastname&gt; and similar. To repeat: if I specify &lt;your name&gt; … and your name is Elcid Barrett, You type Elcid Barrett … and not your name or &lt;Elcid Barret&gt; or similar. (Oh the troubles I’ve seen …) The sample code on this page sometimes copies text from the console, and sometimes shows the actual commands only. The &gt; character at the beginning of the line is always just R’s input prompt, it tells you that you can type something now - you never actually type &gt; at the beginning of a line. If you read: &gt; getwd() you need to type: getwd() If a line starts with [1] or similar, this is R’s output on the console.3 The # character marks the following text as a comment which is not executed by R. These are lines that you do not type. They are program output, or comments, not commands. 2.2.5 Characters Different characters mean different things for computers, and it is important to call them by their right name. / ◁ this is a forward-slash. It leans forward in the reading direction. \\ ◁ this is a backslash. It leans backward in the reading direction. ( ) ◁ these are parentheses. ◁ these are (square) brackets. &lt; &gt; ◁ these are angle brackets. { } ◁ these are (curly) braces. ” ◁ this, and only this is a quotation mark or double quote. All of these are not: “”„«» . They will break your code. Especially the first two are often automatically inserted by MSWord and hard to distinguish.Never, ever edit code in MS Word. Use R or RStudio. Actually, don’t use notepad or TextEdit either. ’ ◁ this, and only this is a single quote. All of these are not: ’’‚‹› . They will break your code. Especially the first two are often automatically inserted by MSWord and hard to distinguish. MSWord is not useful as a code editor. 2.3 The environment In this section we discuss how to download and install the software, how to configure an R session and how to work in the R environment. There are many different ways you can use and setup R. By simply installing R you can use it directly but it is highly recommended that you also install and use RStudio which is an Integrate development environment (IDE) for R. You cannot just download RStudio and use it. It requires an installation of R. You don’t need to install R and RStudio though. You can also use R and RStudio through docker. I highly recommend using docker instead As with many open source projects, R is a constantly evolving language with regular updates. There is a major release once a year with patch releases through out the year. Often scripts and packages will work from one release to the next (ignoring pesky warnings that a package was compiled on a previous version of R is common) but there are exceptions. Some newer packages will only work on the latest version of R so sometimes the choice of upgrading or not using a new package might present themselves. Often, the amount of packages and work that is need to upgrade is not realized until the process has begun. This is where docker demonstrates it most valuable features. You can create a new instance based on the latest release of R and all your needed packages without having to change any of your current settings. If you want you can skip over installing R and and Rstudio and go directly to install docker. There is no requirement to do both. I would recommend going straight to docker! 2.4 Task 1 - Install R Navigate to CRAN (the Comprehensive R Archive Network) and follow the link to Download R for your computer’s operating system. * You can also use one of the mirror sites, if CRAN is down - for example the mirror site at the University of Toronto. A choice of mirror sites is listed on the R-project homepage. Download a precompiled binary (or build) of the R framework to your computer and follow the instructions for installing it. Make sure that the program is the correct one for your version of your operating system. Launch R. Once you see that R is running correctly, you may quit the program for now. The program should open a window –this window is called the R console – and greets you with its input prompt, awaiting your input: I can’t install R. Make sure that the version you downloaded is the right one for your operating system. Also make sure that you have the necessary permissions on your computer to install new software. 2.5 Task 2 - Install RStudio RStudio is a free IDE (Integrated Development Environment) for R. RStudio is a wrapper4 for R and as far as basic R is concerned, all the underlying functions are the same, only the user interface is different (and there are a few additional functions that are very useful e.g. for managing projects). Here is a small list of differences between R and RStudio. pros (some pretty significant ones actually): Integrated version control. Support for “projects” that package scripts and other assets. Syntax-aware code colouring. A consistent interface across all supported platforms. (Base R GUIs are not all the same for e.g. Mac OS X and Windows.) Code autocompletion in the script editor. (Depending on your point of view this can be a help or an annoyance. I used to hate it. After using it for a while I find it useful.) “Function signaturtes” (a list of named parameters) displayed when you hover over a function name. The ability to set breakpoints for debugging in the script editor. Support for knitr, and rmarkdown; also support for R notebooks … (This supports “literate programming” and is actually a big advance in software development) Support for R notebooks. cons (all minor actually): The tiled interface uses more desktop space than the windows of the R GUI. There are sometimes (rarely) situations where R functions do not behave in exactly the same way in RStudio. The supported R version is not always immediately the most recent release. Navigate to the RStudio download Website. Find the right version of the RStudio Desktop installer for your computer, download it and install the software. Open RStudio. Focus on the bottom left pane of the window, this is the “console” pane. Type getwd(). This prints out the path of the current working directory. Make a (mental) note where this is. We usually always need to change this “default directory” to a project directory. 2.6 Docker Changing versions and environments are a continuing struggle with bioinformatics pipelines and computational pipelines in general. An analysis written and performed a year ago might not run or produce the same results when it is run today. Recording package and system versions or not updating certain packages rarely work in the long run. One the best solutions to reproducibility issues is containing your workflow or pipeline in its own coding environment where everything from the operating system, programs and packages are defined and can be built from a set of given instructions. There are many systems that offer this type of control including: Docker. Singularity “A container is a standard unit of software that packages up code and all its dependencies so the application runs quickly and reliably from one computing environment to another.” (“What Is a Container?” n.d.) Why are containers great for Bioiformatics? allows you to create environments to run bioinformatis pipelines. create a consistent environment to use for your pipelines. test modifications to the pipeline without disrupting your current set up. Coming back to an analysis years later and there is no need to install older versions of packages or programming languages. Simply create a container and re-run. All assignments for this course are expected to compile and run. We will be using the bcb420-base-image:winter2025 docker image to run all or your submitted notebooks. If your notebook runs with no errors and renders your html notebook you will recieve full marks for compilation. It is recommended that you do all your work and assignments using this docker image. 2.6.1 What is docker? Docker is a container platform, similar to a virtual machine but better. We can run multiple containers on our docker server. A container is an instance of an image. The image is built based on a set of instructions but consists of an operating system, installed programs and packages. (When backing up your computer you might taken an image of it and restored your machine from this image. It the same concept but the image is built based on a set of elementary commands found in your Dockerfile.) - for overview see here Often images are built off of previous images with specific additions you need for you pipeline. (For example, for this course we use a base image supplied by bioconductorrelease 3.11 and comes by default with basic Bioconductor packages but it builds on the base R-docker images called rocker.) 2.7 Docker - Basic term definition 2.7.1 Container An instance of an image. the self-contained running system. There can be multiple containers derived from the same image. 2.7.2 Image An image contains the blueprint of a container. In docker, the image is built from a Dockerfile 2.7.3 Docker Volumes Anything written on a container will be erased when the container is erased ( or crashes) but anything written on a filesystem that is separate from the contain will persist even after a container is turned off. A volume is a way to assocaited data with a container that will persist even after the container. * maps a drive on the host system to a drive on the container. In the above docker run command (that creates our container) the statement: -v ${PWD}:/home/rstudio/projects maps the directory ${PWD} to the directory /home/rstudio/projects on the container. Anything saved in /home/rstudio/projects will actually be saved in ${PWD} An example: I use the following commmand to create my docker container: docker run -e PASSWORD=changeit --rm \\ -v /Users/risserlin/bcb420_code:/home/rstudio/projects \\ -p 8787:8787 \\ risserlin/bcb420-base-image:winter2025 I create a notebook called task3_bcb420.Rmd and save it in /home/rstudio/projects. Note: Do not save it in /home/rstudio/ which is the default directory RStudio will start in On my host computer, if I go to /Users/risserlin/bcb420_code I will find the file task3_bcb420.Rmd 2.8 Task 3 - Install Docker Download and install docker desktop. Follow slightly different instructions for Windows or MacOS/Linux 2.8.1 Windows it might prompt you to install additional updates (for example - https://docs.Microsoft.com/en-us/windows/wsl/install-win10#step-4---download-the-linux-kernel-update-package) and require multiple restarts of your system or docker. launch docker desktop app. Open windows Power shell navigate to directory on your system where you plan on keeping all your code. For example: C:\\USERS\\risserlin\\bcb420_code Run the following command: (the only difference with the windows command is the way the current directory is written. ${PWD} instead of \"$(pwd)\") docker run -e PASSWORD=changeit --rm \\ -v ${PWD}:/home/rstudio/projects -p 8787:8787 \\ risserlin/bcb420-base-image:winter2025 Windows defender firewall might pop up with warning. Click on Allow access. In docker desktop you see all containers you are running and easily manage them. 2.8.2 MacOS / Linux Open Terminal navigate to directory on your system where you plan on keeping all your code. For example: /Users/risserlin/bcb420_code Run the following command: (the only difference with the windows command is the way the current directory is written. ${PWD} instead of \"$(pwd)\") docker run -e PASSWORD=changeit --rm \\ -v &quot;$(pwd)&quot;:/home/rstudio/projects -p 8787:8787 \\ risserlin/bcb420-base-image:winter2025 2.9 Task 4 - Create your first notebook using Docker 2.9.1 Start coding! Open a web browser to localhost:8787 enter username: rstudio enter password: changeit changing the parameter -e PASSWORD=changeit in the above docker command will change the password you need to specify When you go to localhost:8787 all you get is: Make sure your docker container is running. (If you rebooted your machine you will need to restart the container on reboot.) Make sure you got the right port. After logging in, you will see an Rstudio window just like when you install it directly on your computer. This RStudio will be running in your docker container and will be a completely separate instance from the one you have installed on your machine (with a different set of packages and potentially versions installed). Make sure that you have mapped a volume on your computer to a volume in your container so that files you create are also saved on your computer. That way, turning off or deleting your container or image will not effect your files. The parameter -v ${PWD}:/home/rstudio/projects maps your current directory (i.e. the directory you are in when launching the container) to the directory /home/rstudio/projects on your container. You do not need to use the ${PWD} convention. You can also specify the exact path of the directory you want to map to your container. Make sure to save all your scripts and notebooks in the projects directory. Create your first notebook in your docker Rstudio. Save it. Find your newly created file on your computer. 2.10 Packages R has many powerful functions built in, but one of it’s greatest features is that it is easily extensible. Extensions have been written by legions of scientists for many years, most commonly in the R programming language itself, and made available through CRAN–The Comprehensive R Archive Network or through the Bioconductor project. A package is a collection of code, documentation and (often) sample data. * To use packages, you need to install the package (once). * You can then use all of the package’s functions by prefixing them with the package name and a double colon (eg. package::function()); that’s the preferred way. seqinr::bma(c(&quot;c&quot;,&quot;c&quot;,&quot;a&quot;)) Or you can load all of the package’s functions with a library(package) command, and then use the functions without a prefix. That’s less typing, but it’s also less explicit and you may end up constantly wondering where exactly a particular function came from. In the teaching code for this course, I use the package::function() idiom wherever reasonable. library(seqinr) You can get an overview of installed and loaded packages by opening the Package Manager window from the Packages &amp; Data Menu item. It gives a list of available packages you currently have installed, and identifies those that have been loaded at startup, or interactively. But note, a package does not have to be loaded to be used. 2.11 Task 5 - Experiment with RStudio and packages Navigate to http://cran.r-project.org/web/packages/ and read the page. Navigate to http://cran.r-project.org/web/views/ (the curated CRAN task-views). Follow the link to Genetics and read the synopsis of available packages. The library sequinr sounds useful, but check first whether it has been installed. Follow the exercise below 2.11.1 Exercise In your RStudio window: create a new notebook. go though each of the commands below and add them to your notebook. write your observation for each of commands in the notebook. Add this new notebook to your github repo and link to it in your journal. library() opens a window that lists the packages that are installed on your computer; library() search() - shows which ones are currently loaded. search() ## [1] &quot;.GlobalEnv&quot; &quot;package:stats&quot; &quot;package:graphics&quot; ## [4] &quot;package:grDevices&quot; &quot;package:utils&quot; &quot;package:datasets&quot; ## [7] &quot;package:methods&quot; &quot;Autoloads&quot; &quot;package:base&quot; In the Packages tab of the lower-right pane in RStudio, confirm that seqinr is not yet installed. Follow the link to seqinr to see what standard information is available with a package. Then follow the link to the Reference manual to access the documentation pdf. This is also sometimes referred to as a “vignette” and contains usage hints and sample code. Read the help for vignette. Note that there is a command to extract R sample code from a vignette, to experiment with it. ?vignette Install seqinr from the closest CRAN mirror and load it for this session. Explore some functions. # to get help on using install.packages ?install.packages # Note: the parameter is a quoted string! install.packages(&quot;seqinr&quot;,repos=&quot;https://cran.rstudio.com/&quot;) this will launch a new window with the seqinr package info library(help=&quot;seqinr&quot;) list all the functions available in the seqinr package. #Note: the file must be attached in order for the below function to work library(seqinr) ls(&quot;package:seqinr&quot;) ## [1] &quot;a&quot; &quot;aaa&quot; ## [3] &quot;AAstat&quot; &quot;acnucclose&quot; ## [5] &quot;acnucopen&quot; &quot;al2bp&quot; ## [7] &quot;alllistranks&quot; &quot;alr&quot; ## [9] &quot;amb&quot; &quot;as.alignment&quot; ## [11] &quot;as.matrix.alignment&quot; &quot;as.SeqAcnucWeb&quot; ## [13] &quot;as.SeqFastaAA&quot; &quot;as.SeqFastadna&quot; ## [15] &quot;as.SeqFrag&quot; &quot;autosocket&quot; ## [17] &quot;baselineabif&quot; &quot;bma&quot; ## [19] &quot;c2s&quot; &quot;cai&quot; ## [21] &quot;cfl&quot; &quot;choosebank&quot; ## [23] &quot;circle&quot; &quot;clfcd&quot; ## [25] &quot;clientid&quot; &quot;closebank&quot; ## [27] &quot;col2alpha&quot; &quot;comp&quot; ## [29] &quot;computePI&quot; &quot;con&quot; ## [31] &quot;consensus&quot; &quot;count&quot; ## [33] &quot;countfreelists&quot; &quot;countsubseqs&quot; ## [35] &quot;crelistfromclientdata&quot; &quot;css&quot; ## [37] &quot;dia.bactgensize&quot; &quot;dia.db.growth&quot; ## [39] &quot;dist.alignment&quot; &quot;dotchart.uco&quot; ## [41] &quot;dotPlot&quot; &quot;draw.oriloc&quot; ## [43] &quot;draw.rearranged.oriloc&quot; &quot;draw.recstat&quot; ## [45] &quot;exseq&quot; &quot;extract.breakpoints&quot; ## [47] &quot;extractseqs&quot; &quot;fastacc&quot; ## [49] &quot;gb2fasta&quot; &quot;gbk2g2&quot; ## [51] &quot;gbk2g2.euk&quot; &quot;GC&quot; ## [53] &quot;GC1&quot; &quot;GC2&quot; ## [55] &quot;GC3&quot; &quot;GCpos&quot; ## [57] &quot;get.db.growth&quot; &quot;getAnnot&quot; ## [59] &quot;getAnnot.default&quot; &quot;getAnnot.list&quot; ## [61] &quot;getAnnot.logical&quot; &quot;getAnnot.qaw&quot; ## [63] &quot;getAnnot.SeqAcnucWeb&quot; &quot;getAnnot.SeqFastaAA&quot; ## [65] &quot;getAnnot.SeqFastadna&quot; &quot;getAttributsocket&quot; ## [67] &quot;getFrag&quot; &quot;getFrag.character&quot; ## [69] &quot;getFrag.default&quot; &quot;getFrag.list&quot; ## [71] &quot;getFrag.logical&quot; &quot;getFrag.qaw&quot; ## [73] &quot;getFrag.SeqAcnucWeb&quot; &quot;getFrag.SeqFastaAA&quot; ## [75] &quot;getFrag.SeqFastadna&quot; &quot;getFrag.SeqFrag&quot; ## [77] &quot;getKeyword&quot; &quot;getKeyword.default&quot; ## [79] &quot;getKeyword.list&quot; &quot;getKeyword.logical&quot; ## [81] &quot;getKeyword.qaw&quot; &quot;getKeyword.SeqAcnucWeb&quot; ## [83] &quot;getLength&quot; &quot;getLength.character&quot; ## [85] &quot;getLength.default&quot; &quot;getLength.list&quot; ## [87] &quot;getLength.logical&quot; &quot;getLength.qaw&quot; ## [89] &quot;getLength.SeqAcnucWeb&quot; &quot;getLength.SeqFastaAA&quot; ## [91] &quot;getLength.SeqFastadna&quot; &quot;getLength.SeqFrag&quot; ## [93] &quot;getlistrank&quot; &quot;getliststate&quot; ## [95] &quot;getLocation&quot; &quot;getLocation.default&quot; ## [97] &quot;getLocation.list&quot; &quot;getLocation.logical&quot; ## [99] &quot;getLocation.qaw&quot; &quot;getLocation.SeqAcnucWeb&quot; ## [101] &quot;getName&quot; &quot;getName.default&quot; ## [103] &quot;getName.list&quot; &quot;getName.logical&quot; ## [105] &quot;getName.qaw&quot; &quot;getName.SeqAcnucWeb&quot; ## [107] &quot;getName.SeqFastaAA&quot; &quot;getName.SeqFastadna&quot; ## [109] &quot;getName.SeqFrag&quot; &quot;getNumber.socket&quot; ## [111] &quot;getSequence&quot; &quot;getSequence.character&quot; ## [113] &quot;getSequence.default&quot; &quot;getSequence.list&quot; ## [115] &quot;getSequence.logical&quot; &quot;getSequence.qaw&quot; ## [117] &quot;getSequence.SeqAcnucWeb&quot; &quot;getSequence.SeqFastaAA&quot; ## [119] &quot;getSequence.SeqFastadna&quot; &quot;getSequence.SeqFrag&quot; ## [121] &quot;getTrans&quot; &quot;getTrans.character&quot; ## [123] &quot;getTrans.default&quot; &quot;getTrans.list&quot; ## [125] &quot;getTrans.logical&quot; &quot;getTrans.qaw&quot; ## [127] &quot;getTrans.SeqAcnucWeb&quot; &quot;getTrans.SeqFastadna&quot; ## [129] &quot;getTrans.SeqFrag&quot; &quot;getType&quot; ## [131] &quot;gfrag&quot; &quot;ghelp&quot; ## [133] &quot;gln&quot; &quot;glr&quot; ## [135] &quot;gls&quot; &quot;is.SeqAcnucWeb&quot; ## [137] &quot;is.SeqFastaAA&quot; &quot;is.SeqFastadna&quot; ## [139] &quot;is.SeqFrag&quot; &quot;isenum&quot; ## [141] &quot;isn&quot; &quot;kaks&quot; ## [143] &quot;kdb&quot; &quot;knowndbs&quot; ## [145] &quot;lseqinr&quot; &quot;modifylist&quot; ## [147] &quot;move&quot; &quot;mv&quot; ## [149] &quot;n2s&quot; &quot;oriloc&quot; ## [151] &quot;parser.socket&quot; &quot;peakabif&quot; ## [153] &quot;permutation&quot; &quot;pga&quot; ## [155] &quot;plot.SeqAcnucWeb&quot; &quot;plotabif&quot; ## [157] &quot;plotladder&quot; &quot;plotPanels&quot; ## [159] &quot;pmw&quot; &quot;prepgetannots&quot; ## [161] &quot;prettyseq&quot; &quot;print.qaw&quot; ## [163] &quot;print.SeqAcnucWeb&quot; &quot;query&quot; ## [165] &quot;quitacnuc&quot; &quot;read.abif&quot; ## [167] &quot;read.alignment&quot; &quot;read.fasta&quot; ## [169] &quot;readBins&quot; &quot;readfirstrec&quot; ## [171] &quot;readPanels&quot; &quot;readsmj&quot; ## [173] &quot;rearranged.oriloc&quot; &quot;recstat&quot; ## [175] &quot;residuecount&quot; &quot;reverse.align&quot; ## [177] &quot;rho&quot; &quot;rot13&quot; ## [179] &quot;s2c&quot; &quot;s2n&quot; ## [181] &quot;savelist&quot; &quot;SEQINR.UTIL&quot; ## [183] &quot;setlistname&quot; &quot;splitseq&quot; ## [185] &quot;stresc&quot; &quot;stutterabif&quot; ## [187] &quot;summary.SeqFastaAA&quot; &quot;summary.SeqFastadna&quot; ## [189] &quot;swap&quot; &quot;syncodons&quot; ## [191] &quot;synsequence&quot; &quot;tablecode&quot; ## [193] &quot;test.co.recstat&quot; &quot;test.li.recstat&quot; ## [195] &quot;translate&quot; &quot;trimSpace&quot; ## [197] &quot;uco&quot; &quot;ucoweight&quot; ## [199] &quot;where.is.this.acc&quot; &quot;words&quot; ## [201] &quot;words.pos&quot; &quot;write.fasta&quot; ## [203] &quot;zscore&quot; In Rstudio this will open the method description for the method a in the Help pane. ?seqinr::a Run the fiction to see the output seqinr::a(&quot;Tyr&quot;) ## [1] &quot;Y&quot; What does function below do? enter your results in your journal seqinr::words(3, c(&quot;A&quot;, &quot;G&quot;, &quot;C&quot;, &quot;U&quot;)) The installation fails. You might see an error message such as this: Warning message: package ‘XYZ’ is not available (for R version 3.2.2) This can mean several things: The package is not available on CRAN. Try Bioconductor instead or Google for the name to find it. The package requires a newer version of R than the one you have. Upgrade, or see if a legacy version exists. A comprehensive set of reasons and their resolution is here on stackoverflow. We have seen the following on Windows systems when typing library(help=“seqinr”) Error in formatDL(nm, txt, indent = max(nchar(nm, “w”)) + 3) : incorrect values of ‘indent’ and ‘width’ Anecdotally this was due to a previous installation problem with a mixup of 32-bit and 64-bit R versions, although another student told us that the problem simply went away when trying the command again. Whatever: Make sure you have the right R version installed for your operating system. Uninstall and reinstall when in doubt. Conflicting libraries can be the source of strange misbehaviour. The fact that these methods work, shows that the package has been downloaded, installed, its functions are now available with the package name prefix and any datasets it contains can be loaded. Just like many other packages, seqinr comes with a number of datafiles. Try: What does this function do? ?data What is an example of data that is available for the seqinr package? data(package=&quot;seqinr&quot;) # list the available data load ‘’aaindex’’. Describe this data. See here for more information. data(aaindex, package=&quot;seqinr&quot;) what is this? ?aaindex two of the indices … aaindex$FASG890101 ## $H ## [1] &quot;FASG890101&quot; ## ## $D ## [1] &quot;Hydrophobicity index (Fasman, 1989)&quot; ## ## $R ## [1] &quot;&quot; ## ## $A ## [1] &quot;Fasman, G.D.&quot; ## ## $T ## [1] &quot;Prediction of Protein Structure and the Principles of Protein Conformation&quot; ## ## $J ## [1] &quot;Plenum, New York 1989, page 457, Table XVII&quot; ## ## $C ## [1] &quot;MIYS990105 0.959 MIYS990103 0.957 MEIH800102 0.951MIYS990104 0.949 RACS770102 0.935 GUYH850101 0.934MIYS990102 0.929 MIYS990101 0.926 MEIH800101 0.919KRIW790101 0.914 GUYH850102 0.909 VINM940101 0.904KRIW790102 0.882 GUYH850104 0.872 RACS770101 0.872GRAR740102 0.872 CORJ870108 0.872 KARP850102 0.871OOBM770103 0.869 VINM940103 0.868 OOBM770101 0.868KRIW710101 0.865 KIDA850101 0.861 GUYH850103 0.860PUNT030102 0.853 PUNT030101 0.845 FUKS010104 0.844RACS770103 0.842 ROSM880102 0.839 JANJ780103 0.838VINM940102 0.836 PARJ860101 0.825 KUHL950101 0.821JANJ780101 0.813 FUKS010103 0.812 GUOD860101 -0.801DESM900101 -0.808 CORJ870105 -0.821 ROSM880105 -0.822PONP800106 -0.823 NADH010101 -0.838 CORJ870106 -0.841KYTJ820101 -0.844 CIDH920103 -0.846 CHOC760103 -0.849BASU050101 -0.856 JURD980101 -0.857 PLIV810101 -0.858BAEK050101 -0.859 CIDH920105 -0.860 ROBB790101 -0.860EISD860103 -0.863 CORJ870104 -0.865 CORJ870107 -0.871JANJ790102 -0.875 CORJ870103 -0.876 NADH010105 -0.877DESM900102 -0.879 BASU050102 -0.881 JANJ790101 -0.885CIDH920104 -0.903 JANJ780102 -0.903 MANP780101 -0.904PONP930101 -0.907 ZHOH040103 -0.910 FAUJ830101 -0.911PONP800108 -0.913 BASU050103 -0.915 CORJ870101 -0.921NISK800101 -0.923 MEIH800103 -0.924 CASG920101 -0.924WERD780101 -0.926 BIOV880102 -0.928 NADH010102 -0.929PONP800101 -0.932 PONP800103 -0.936 MIYS850101 -0.938PONP800102 -0.944 NADH010104 -0.944 NADH010103 -0.945NISK860101 -0.949 ROSG850102 -0.976 RADA880108 -0.977BIOV880101 -0.982&quot; ## ## $I ## Ala Arg Asn Asp Cys Gln Glu Gly His Ile Leu Lys Met ## -0.21 2.11 0.96 1.36 -6.04 1.52 2.30 0.00 -1.23 -4.81 -4.68 3.88 -3.66 ## Phe Pro Ser Thr Trp Tyr Val ## -4.65 0.75 1.74 0.78 -3.32 -1.01 -3.50 aaindex$PONJ960101 ## $H ## [1] &quot;PONJ960101&quot; ## ## $D ## [1] &quot;Average volumes of residues (Pontius et al., 1996)&quot; ## ## $R ## [1] &quot;PMID: 8950272&quot; ## ## $A ## [1] &quot;Pontius, J., Richelle, J. and Wodak, S.J.&quot; ## ## $T ## [1] &quot;Deviations from standard atomic volumes as a quality measure for protein crystal structures&quot; ## ## $J ## [1] &quot;J. Mol. Biol 264, 121-136 (1996) (Disulfide bonded cysteine, 102.4)&quot; ## ## $C ## [1] &quot;HARY940101 0.989 CHOC750101 0.966 FAUJ880103 0.963TSAJ990102 0.962 CHOC760101 0.961 TSAJ990101 0.960BIGC670101 0.950 GOLD730102 0.947 FASG760101 0.945KRIW790103 0.943 CHAM820101 0.938 GRAR740103 0.937LEVM760102 0.930 LEVM760105 0.928 CHAM830106 0.917FAUJ880106 0.913 DAWD720101 0.873 ROSG850101 0.862RADA880106 0.860 LEVM760107 0.827 ZHOH040102 0.823RADA880103 -0.873&quot; ## ## $I ## Ala Arg Asn Asp Cys Gln Glu Gly His Ile Leu Lys Met ## 91.5 196.1 138.3 135.2 114.4 156.4 154.6 67.5 163.2 162.6 163.4 162.5 165.9 ## Phe Pro Ser Thr Trp Tyr Val ## 198.8 123.4 102.0 126.0 209.8 237.2 138.4 Let’s use the data: plot amino acid single-letter codes by hydrophobicity and volume. The values come from the dataset. Copy and paste the commands. plot(aaindex$FASG890101$I, aaindex$PONJ960101$I, xlab=&quot;hydrophobicity&quot;, ylab=&quot;volume&quot;, type=&quot;n&quot;) text(aaindex$FASG890101$I, aaindex$PONJ960101$I, labels=a(names(aaindex$FASG890101$I))) Now, just for fun, let’s use seqinr package functions to download a sequence and calculate some statistics (however, not to digress too far, without further explanation at this point). Copy the code below and paste it into the R-console. seqinr::choosebank(&quot;swissprot&quot;) mySeq &lt;- seqinr::query(&quot;mySeq&quot;, &quot;N=MBP1_YEAST&quot;) mbp1 &lt;- seqinr::getSequence(mySeq) seqinr::closebank() x &lt;- seqinr::AAstat(mbp1[[1]]) barplot(sort(x$Compo), cex.names = 0.6) We could have “loaded” the package with library(), and then used the functions without prefix. Less typing, but also less explicit. library(seqinr) choosebank(&quot;swissprot&quot;) mySeq &lt;- query(&quot;mySeq&quot;, &quot;N=MBP1_YEAST&quot;) mbp1 &lt;- getSequence(mySeq) closebank() x &lt;- AAstat(mbp1[[1]]) barplot(sort(x$Compo), cex.names = 0.6) In general we will be using the idiom with the package prefix throughout the course. The function requireNamespace() is useful because it does not produce an error when a package has not been installed. It simply returns TRUE if successful or FALSE if not. Therefore one can use the following code idiom in R scripts to avoid downloading the package every time the script is called. if (! requireNamespace(&quot;seqinr&quot;, quietly=TRUE)) { install.packages(&quot;seqinr&quot;) } You can get package information with the following commands: library(help = seqinr) # basic information browseVignettes(&quot;seqinr&quot;) # available vignettes ## No vignettes found by browseVignettes(&quot;seqinr&quot;) data(package = &quot;seqinr&quot;) # available datasets Note that install.packages() takes a (quoted) string as its argument, but library() takes a variable name (without quotes). New users usually get this wrong :-) Note that the Bioconductor project has its own installation system, the Biocmanager::install() function. It is explained here. Note, just to mention it at this point: to install packages that are not on CRAN or Bioconductor, you need the devtools package. 2.11.2 Finding packages One of the challenges of working with R is the overabundance of options. CRAN has over 10,000 packages and Bioconductor has over 1,300 more. How can you find ones that are useful to your work? There’s actually a package to help you do that, the sos package on CRAN. Try this: if (! requireNamespace(&quot;sos&quot;, quietly=TRUE)) { install.packages(&quot;sos&quot;) } library(help = sos) # basic information browseVignettes(&quot;sos&quot;) # available vignettes sos::findFn(&quot;moving average&quot;) Or: Read a CRAN Task View for your area of interest or the Bioconductor Views; Search on “Metacran” (“regex” example here”) … or “MRAN” (“regex” example here”, not that the results are not identical); and, as always, Google. 2.11.3 Self-evaluation Question 1 - What is the purpose of this code? if (! requireNamespace(&quot;seqinr&quot;, quietly = TRUE)) { install.packages(&quot;seqinr&quot;) } Why not just use: install.packages(“seqinr”) Answer: This code idiom is useful in scripts, to ensure a package is installed before we try to use its functions. If we would simply use install.packages(“seqinr”), the package would be downloaded from CRAN every time the script is run. That would make our script slow, and require available internet access for the script to run. In the code above, the package is downloaded only when requireNamespace() returns FALSE, which presumably means the package has not yet been downloaded. 2.11.4 Further reading, links and resources Wikipedia article on the R statistics environment and programming language The R project homepage The R Studio IDE CRAN–The Comprehensive R Archive Network The Bioconductor project homepage R bloggers Package finding strategies (Revolutions Analytics Blog) Intro to R packages (at DataCamp). “The Impressive Growth of R” (Stackoverflow Data Analytics Team Blog) Ten simple rules for biologists learning to program - Carey and Papin advise novice biologist programmers how to begin. Much of this paper resonates well with our Introduction to R learning units. Good context for a beginning, to get a sense of where we are going with this. If in doubt, ask! If anything about this learning unit is not clear to you, do not proceed blindly but ask for clarification. Post your question on the course mailing list: others are likely to have similar problems. Or send an email to your instructor. Author: Boris Steipe boris.steipe@utoronto.ca Created: 2017-08-05 Modified: 2019-01-07 Version: 1.1 Version history: 1.1 Change from require() to requireNamespace() and use ::() idiom. 1.02 Maintenance 1.0.1 Removed mention of Sweave - obsolete, and broken link. Added mention of “literate programming”. 1.0 Completed to first live version 0.1 Material collected from previous tutorial 2.11.5 Updated Revision history Revision Author Date Message 5152496 Ruth Isserlin 2019-12-25 Fixed issue with task numbering because of a remove all elements call in the 2nd chapter fab47ae Ruth Isserlin 2019-12-24 initial check in of R basics book 2.11.6 Footnotes: References “What Is a Container?” n.d. Docker. https://www.docker.com/resources/what-container. and when you click on the arrow to the left, this will take you back to where you came from↩︎ Proportional fonts are for elegant document layout. Monospaced fonts are needed to properly align characters in columns. For code and sequences, we always use monospaced font.↩︎ [1] means: the following is the first (often only) element of a vector.↩︎ A “wrapper” program uses another program’s functionality in its own context. RStudio is a wrapper for R since it does not duplicate R’s functions, it runs the actual R in the background.↩︎ "],["r-setup.html", "Chapter 3 Setup R to work with it 3.1 Overview 3.2 Your Course Folder 3.3 “Projects” 3.4 Git Version control 3.5 Task 6 - Git 3.6 Working directory 3.7 Task 7- Working directory 3.8 .Rprofile - startup commands 3.9 Task 8 - .Rprofile 3.10 The “Workspace” 3.11 Self-evaluation", " Chapter 3 Setup R to work with it (R projects; working with git version control via RStudio; the history mechanism and why not to use it; .Rprofile to customize startup behaviour; the working directory.) 3.1 Overview ###Abstract: This unit discusses the setup of a working session with RStudio. 3.1.1 Objectives: This unit will: introduce R projects; start working with git version control via RStudio; discuss the history mechanism and why not to use it; mention .Rprofile to customize startup behaviour; and teach you to define the Working Directory of an R session. 3.1.2 Outcomes: After working through this unit you: have verified that you can install R projects from GitHub; know what the .Rprofile file is for; can get and set the path of the current Working Directory. 3.1.3 Deliverables: Time management: Before you begin, estimate how long it will take you to complete this unit. Then, record in your course journal: the number of hours you estimated, the number of hours you worked on the unit, and the amount of time that passed between start and completion of this unit. Journal: Document your progress in your Course Journal. Some tasks may ask you to include specific items in your journal. Don’t overlook these. Insights: If you find something particularly noteworthy about this unit, make a note in your insights! page. 3.1.4 Prerequisites RPR-Installation (Installing R and RStudio) 3.2 Your Course Folder Your Course Folder should already exist. Take note! When you write a Windows paths in an R command, you have to use the “wrong” forward slash to separte directories and files. R will translate these “Unix-style”” paths into Windows-style paths automatically when it negotiates with the operating system. But the backslash is interpreted as an “escape” character that gives the character the follows it a special meaning.5 Folder name and path examples /Users/Pierette/Documents/BCB420 ◁ Looking good on a Mac. C:\\Users\\Pulcinella\\Documents\\CBW ◁ Looking good on a Windows computer. “C:/Users/Pulcinella/Documents/CBW” ◁ Looking good inside R on a Windows computer (note the quotation marks!). C:\\Users\\Pantalone\\Documents\\BCH1441 (2017) ◁ Wrong. No special characters please. /Users/Brighella/Documents/UofT Stuffz/Courses/more/Comp Sys biol. course ◁ Wrong. Please read instructions more carefully. C:\\Users\\Tartaglia\\Documents\\KUWTK\\&lt;Coursecode&gt; ◁ I can’t even … 3.3 “Projects” We will make extensive use of “projects” in class. Read more about projects in RStudio here. 3.4 Git Version control We will also make extensive use of version control. In fact, we will now load a project via Git version control from its free, public repository on GitHub. 3.5 Task 6 - Git Read more about Version Control in RStudio here. Follow the instructions to install git on your computer. Then do the following: open RStudio Select File → NewProject… Click on Version Control Click on Git Enter https://github.com/hyginn/R_Exercise-BasicSetup as the Repository URL. Type a character, the Project directory name field should then autofill to read R_Exercise-BasicSetup Click on Browse… to find your Course Folder. (The one that you have already created). (If you are using docker make sure the directory you choose is in the projectes directory so it gets stored in your mapped volume on your machine) Click Open. Click Create Project; the project files should be downloaded and the console should prompt you to type init() to begin. Type init() into the console pane. An R script should load. Explore the script and follow its instructions. I get an error message: “Git not found”. * The simplest reason is that you may have had RStudio open while installing git. Just restart RStudio. * The executable for Git (the Git “program” - “git.exe” on Windows, “git” elsewhere) needs to be on your system’s path, or correctly specified in RStudio’s options. The correct “path” to Git will depend on your operating system, and how git was installed. To find where git is installed – * On Mac and Unix systems, open a Terminal window1 and type which git. This will either print the path (Yay), or tell you that git is not found. The latter could have two reasons: either git has no been installed in the first place, or it has been installed in a non-standard location by whatever installation manager you have used. Ask Google to help you figure out how to solve your specific case. * On Windows you can find the location of the executable by searching “git.exe” in your “programs and files”. Once it’s been found, right click on it and select “Open file location” from the options. It might be in C:Files.exe but the exact location depends on your operating system. * Once you know the path to your git executable, open File → Preferences, click on the Git/SVN option, click on the Browse button, and find the correct folder. On Macs you may need to click G to open the “Go to …” dialogue, then type the top-folder of the path (e.g. /usr) and click your way down to folder where the program lives. Find the installation directory and select git.exe. Then click “ok”. * Then try again to create the project and let us know what happened in case it still did not work. I get an error message like “directory exists and is not empty”. * A directory with the name of the project already exists in the location in which you are asking RStudio to create the project (the Course Folder). Either delete the existing directory, or install the project into a different parent directory. The git icon has disappeared. * I have seen this happen when somehow the path to git has changed. Make sure the correct path to git is set in your File → Preferences → Git/SVN. Open Tools → Project options… → Git/SVN. Next to Version control system git must be selected, not (None). If it is (None), change this to git. If that’s not an option, the path is not correct. Go back to (A). I think you may need to restart RStudio then and reload your project via the Files → Recent projects… menu for the git icon and the version control options to reappear. 3.6 Working directory To locate a file in a computer, one has to specify the filename and the directory in which the file is stored; this is also called the path of the file. However R uses a default working directory, which is assumed if no path is specified. This working directory for R is either the directory in which the R-program has been installed, or some other directory, that has been defined in a startup script, or specifically defined with the command setwd(“”) at any time. You can execute the command getwd() to list what the Working Directory is currently set to: getwd() ## [1] &quot;/home/rstudio/projects/R_basics&quot; In RStudio, the contents of the working directory is listed in the Files Pane (lower-right). It is convenient to put all your R-input and output files into a project specific directory and then define this to be the “Working Directory”. Use the setwd() command for this. setwd() requires an argument that you type between the parentheses: a string with the directory path, or a variable containing such a string. Strings in R are delimited with ” or ’ characters. If the directory does not exist, an Error will be reported. Make sure you have created the directory. On Mac and Unix systems, the usual shorthand notation for relative paths can be used: ~ for the home directory, . for the current directory, .. for the parent of the current directory. If you use a Windows system, you need to know that backslashes – “\\” – have a special meaning for R, they work as escape characters. For example the string “\\n” means newline, and “\\t” means tab. Thus R gets confused when you put backslashes into string literals, such as Windows path names. R has a simple solution: you simply use forward slashes instead of backslashes when you specify paths, and R will translate them correctly when it talks to your operating system. Instead of C:\\documents\\projectfiles you write C:/documents/projectfiles. Also note that on Windows the ~ tilde is a shorthand for the directory in which R is installed, not the user’s home directory. My home directory… original_dir &lt;- getwd() setwd(&quot;~&quot;) # Note: ~ is the &quot;tilde&quot; - the squiggly line - not the straight hyphen getwd() Relative path: home directory, up one level, then down into baderlab’s home directory) setwd(&quot;~/../&quot;) getwd() Absolute path: specify the entire string) setwd(&quot;/home/rstudio/projects&quot;) getwd() Reset the directory to the original directory setwd(original_dir) In RStudio you can use the Session → Set Working Directory menu: This includes the useful option to set the current project directory as the working directory 6. Or in the Files browser in the bottom right by clicking on the More option: You can set the current directory to the working directory. 3.7 Task 7- Working directory Since you have gone through the script of the BasicSetup project, your working directory should be set to this project directory (I have configured the project to do this automatically.) Figure out the path to its parent directory - i.e. the course- or workshop directory you created at the beginning. Use setwd(“”) to set the Working Directory to the Course Folder. Confirm that this has worked by typing getwd() and list.files(). The Working Directory functions can also be accessed through the Menu, under Misc. 3.8 .Rprofile - startup commands Often, when working on a project, you would like to start off in your working directory right away when you start up R, instead of typing the setwd() command. This is easily done in a special R-script that is executed automatically on startup7. The name of the script is .Rprofile and R expects to find it in the user’s home directory. You can edit these files with a simple text editor like Textedit (Mac), Notepad (windows) or Gedit (Linux) - or, of course, by opening it in RStudio - don’t forget that a code editor is also a text editor8. Besides setting the working directory, other items that might go into such a file could be libraries that you often use constants that are not automatically defined functions that you would like to preload. For more details, use R’s help function: ?Startup 3.9 Task 8 - .Rprofile Just for information: locate the .Rprofile file in the RStudio file pane; click on it to open it in the text-editing window. This way you could change it and save the changes. However, don’t do that now but Close the file again. 3.10 The “Workspace” During an R session, you might define a large number of R-objects: variables, data structures, functions etc., and you might load packages and scripts. All of this information is stored in the so-called “Workspace”. When you quit R you have the option to save the Workspace; it will then be restored in your next session. Now, you might think: how convenient - I can just stop R, and when I restart it, it will go into the same state as it was. But no. Restoring the Workspace from a previous state is actually a bad idea: if you load data or variables in a startup script, they may be overwritten with a corrupted version that you happened to save in the workspace when you last quit. This is very hard to troubleshoot. Essentially, when you save and reload your Workspace habitually, you have overlapping and potentially conflicting behaviour of startup script and Workspace restore. What I recommend instead is the following: Never save the Workspace. Always work from scripts. Write your scripts so that you can easily recreate all objects you need to continue your analysis. If some objects are expensive to compute, you can always save() and later load() them explicitly. In fact, restoring the Workspace does the same thing, but you have less control regarding whether the version of your objects are correct, and what temporary variables may be loaded as well. In this way, you work with explicit instructions, not implicit behaviour. Explicit beats implicit. List the current workspace contents: initially it only contains the init() function that was loaded from the .Rprofile script on startup. ls() ## [1] &quot;aaindex&quot; &quot;githistory2table&quot; &quot;task_counter&quot; Initialize three variables a &lt;- 3 b &lt;- 4 c &lt;- sqrt(a^2 +b^2) ls() ## [1] &quot;a&quot; &quot;aaindex&quot; &quot;b&quot; &quot;c&quot; ## [5] &quot;githistory2table&quot; &quot;task_counter&quot; Save one item in an .RData file. save(a, file = &quot;tmp.RData&quot;) Remove one item from the Workspace. (Note: the argument for rm() is not the string “a”, but the variable name a. No quotation marks!) rm(a) ls() ## [1] &quot;aaindex&quot; &quot;b&quot; &quot;c&quot; &quot;githistory2table&quot; ## [5] &quot;task_counter&quot; Load what you previously saved. load(&quot;tmp.RData&quot;) ls() ## [1] &quot;a&quot; &quot;aaindex&quot; &quot;b&quot; &quot;c&quot; ## [5] &quot;githistory2table&quot; &quot;task_counter&quot; Note: you can save() more than one item in an .RData file. When you then load() the file, all of the objects it contains are loaded. You don’t assign these objects - they are being restored. We can use the output of ls() as input to rm() to remove all items from the workspace. (cf. ?rm for details) rm(list=setdiff(ls(), &quot;task_counter&quot;)) ls() ## [1] &quot;task_counter&quot; The contents of the workspace is displayed in RStudio’s Environment Pane (top-right). You can see a little “broom” icon at the top that you can click to remove all items from the workspace. 3.11 Self-evaluation ##Further reading, links and resources If in doubt, ask! If anything about this learning unit is not clear to you, do not proceed blindly but ask for clarification. Post your question on the course mailing list: others are likely to have similar problems. Or send an email to your instructor. Author: Boris Steipe boris.steipe@utoronto.ca Created: 2017-08-05 Modified: 2019-01-07 Version: 1.1.1 Version history: 1.1.1 Maintenance 1.1 Fixed display bug with “=” in template code; moved to GeSHi formatting. 1.0 Completed to first live version 0.1 Material collected from previous tutorial 3.11.1 Updated Revision history Revision Author Date Message 5152496 Ruth Isserlin 2019-12-25 Fixed issue with task numbering because of a remove all elements call in the 2nd chapter fab47ae Ruth Isserlin 2019-12-24 initial check in of R basics book 3.11.2 Footnotes: For example C:Documentswould be interpreted as C:Documentsew because is the linebreak character. Even though that’s actually the path name on Windows, in an R command you have to write C:Documents/new↩︎ and when you click on the arrow to the left, this will take you back to where you came from↩︎ Projects that I create for teaching are configured to use this option by default, thus once the project is loaded, the Working Directory should already be correctly set.↩︎ Actually, the first script that runs is Rprofile.site which is found on Linux and Windows machines in the C:\\Program Files\\R\\R-{version}\\etc directory. But not on Macs.↩︎ Operating systems commonly hide files whose name starts with a period “.” from normal directory listings. All files however are displayed in RStudio’s File pane. Nevertheless, it is useful to know how to view such files by default. On Macs, you can configure the Finder to show you such “hidden files” by default. To do this: (i) Open a terminal window; (ii) Type: $defaults write com.apple.Finder AppleShowAllFiles YES (iii) Restart the Finder by accessing Force quit (under the Apple menu), selecting the Finder and clicking Relaunch. (iV) If you ever want to revert this, just do the same thing but set the default to NO instead.↩︎ "],["r-console.html", "Chapter 4 Console, Scripts and Notebooks 4.1 Overview 4.2 Typing code or executing it? 4.3 User interface 4.4 Self-evaluation 4.5 Further reading, links and resources", " Chapter 4 Console, Scripts and Notebooks (Code interactively or from scripts.) 4.1 Overview 4.1.1 Abstract: This unit discusses use working from the RStudio console vs. working from scripts. 4.1.2 Objectives: This unit discusses principles of working interactively vs. working from scripts. 4.1.3 Outcomes: After working through this unit you: are familiar with the advantages of working from script files; should begin always working from script files in your own practice. 4.1.4 Deliverables: Time management: Before you begin, estimate how long it will take you to complete this unit. Then, record in your course journal: the number of hours you estimated, the number of hours you worked on the unit, and the amount of time that passed between start and completion of this unit. Journal: Document your progress in your Course Journal. Some tasks may ask you to include specific items in your journal. Don’t overlook these. Insights: If you find something particularly noteworthy about this unit, make a note in your insights! page. 4.1.5 Prerequisites RPR-Installation (Installing R and RStudio) 4.2 Typing code or executing it? The RStudio “console” is the bottom-left pane into which you can type commands for execution, and which will contain the output of print() or cat() commands. Commands can be: directly typed into the console; copied by you from the Wiki and pasted into the console; or executed from a script (i.e. a text-file of R commands that can run as a program), either by selecting and executing the code, or by executing the entire script with the source(“”) command. However, note the following: it is convenient to copy/paste code, but you don’t learn how to write code through that. Practice has shown that it is better to actually type commands, even if you are just re-typing code from a book or online. Actively typing out the code character by character ensures you are reading and translating the code, and notice if anything is not entirely clear.9 In computer code, every single character matters. For example, I expect that by typing out commands you will be much less likely to confuse = with &lt;- or even ==. Also, you will sometimes mistype and create errors. That’s actually good, because you quickly learn to spot errors, fix them, and resume. That way you build confidence. Regarding the larger scripts we load from GitHub - these are too long to be retyped. Select the line, or parts of the line, or a larger block of code that you want to execute, then press R, or (depending on your operating system) to execute the selected block. In this case you’ll need extra effort to discipline yourself and actually read and understand every single character and command. The point is not to execute the scripts. The point is to understand their contents. The best way to do this is to edit the code, vary parameters, try alternatives and in general play. Actually working with code - i.e. developing code for the lab - is another story. In this case scripts are indispensable for development. I type all my R code into a script, never directly into the console - in this way it is much easier to come back, change things and recreate whatever analysis I was doing: this is essential for “reproducible research”. I type into the script, save the script from time to time, and execute commands from the script, not the console - that’s the easiest way to modify and develop. Making script and console work hand in hand is the way to work with R. There are four major advantages: The script is an accurate record of my procedure so I know exactly what I have done; I add numerous comments, to record what I was thinking when I developed it; I can immediately reproduce the entire analysis from start to finish, simply by rerunning the script; I can reuse parts easily, thus making new analyses quick to develop; If I keep my script under version control, I can return to previous versions and undo errors. These were actually five points. 4.2.1 RNotebooks Building on this, RNotebooks are one step up on scripts. RNotebooks, similiar to jupyter notebooks are a mixture of markdown and code (For all the many uses of R markdown see: R Markdown: The Definitive Guide). They can be rendered into multiple formats (html, pdf and even into Word) and serve as journal page, report, or full summary of the work involved. If generating a report to be given to collaborators, who are interested in the results, code sections can be hidden. Additionally, parameters can be specified for a notebook similar to a function call and an entire pipeline can be run on multiple datasets generating a report for each separately (see here for details on using parameters). The major advantages of scripts are reiterated for RNotebooks with small modifications: The RNotebook is an accurate record of my procedure so I know exactly what I have done; I add text, figures, explanations, table of contents, references…, to record what I was thinking when I developed it; I can immediately reproduce the entire analysis from start to finish, simply by rerunning the RNotebook with different defined parameters; I can reuse parts easily, thus making new analyses quick to develop; If I keep my RNotebook under version control, I can return to previous versions and undo errors. 4.3 User interface Both R and RStudio have a GUI10 to lay out common tasks. For example, there are a number of menu items, many of which are similar to other programs you will have worked with (“File”, “Edit”, “Format”, “Window”, “Help” …). But note: all of these tasks can also be accessed through the command line in the console. In general, GUIs are useful when you are not sure what you want to do or how to go about it; the command line is much more powerful when you have more experience and know your way around in principle. R gives you both options. 4.4 Self-evaluation 4.5 Further reading, links and resources If in doubt, ask! If anything about this learning unit is not clear to you, do not proceed blindly but ask for clarification. Post your question on the course mailing list: others are likely to have similar problems. Or send an email to your instructor. Author: Boris Steipe boris.steipe@utoronto.ca Created: 2017-08-05 Modified: 2018-05-04 Version: 1.0.1 Version history: 1.0.1 Maintenance 1.0 Completed to first live version 0.1 Material collected from previous tutorial 4.5.1 Updated Revision history Revision Author Date Message 5152496 Ruth Isserlin 2019-12-25 Fixed issue with task numbering because of a remove all elements call in the 2nd chapter fab47ae Ruth Isserlin 2019-12-24 initial check in of R basics book 4.5.2 Footnotes: We use a predictive mental contents-model when we type - something like an inbuilt autocorrect-suggestion mechanism; thus if you type something unfamiliar or surprising (e.g. a subtle detail of syntax), you will notice and be able to figure out the issue. Pasting code is a merely mechanical activity.↩︎ A GUI is a Graphical User Interface, it has windows and menu items, as opposed to a “command line interface”.↩︎ "],["r-help.html", "Chapter 5 Getting help for R 5.1 Overview 5.2 The Help system 5.3 Task 9 - R help 5.4 Task 10 - reproducible example 5.5 Self-evaluation 5.6 Notes 5.7 Further reading, links and resources", " Chapter 5 Getting help for R (The internal R help system; other help resources.) 5.1 Overview 5.1.1 Abstract: This unit discusses the available Help resources for R programming and develops effective strategies for solving problems. 5.1.2 Objectives: This unit will: introduce the inbuilt R help system; point you to useful alternatives; discuss how to write effective questions on technical forums and mailing lists. 5.1.3 Outcomes: After working through this unit you: have used the R help system; are able to get help on a function: via R’s internal system, via Web searches, or by asking effective questions (including Minimal Working Examples - MWE) on mailing lists. 5.1.4 Deliverables: Time management: Before you begin, estimate how long it will take you to complete this unit. Then, record in your course journal: the number of hours you estimated, the number of hours you worked on the unit, and the amount of time that passed between start and completion of this unit. Journal: Document your progress in your Course Journal. Some tasks may ask you to include specific items in your journal. Don’t overlook these. Insights: If you find something particularly noteworthy about this unit, make a note in your insights! page. 5.1.5 Prerequisites RPR-Installation (Installing R and RStudio) 5.2 The Help system 5.3 Task 9 - R help Start RStudio (if it’s not already open) and as you work through the sections below, type the commands and explore what they do. If all you need is the correct name of a function (eg. was it list_files(), list.files(), or listFiles()?), just type the first three characters of the function name and use RStudio’s autocomplete mechanism to find what you need. If you are wondering about the parameters of a function, just hover the cursor over the function name in the script pane or the command line in the console and wait a moment: a little window with the function signature will pop up. But for more detailed information, help is available for all commands as well as for the R syntax. As well, help is available to find the names of commands when you are not sure of them. You can get help through the command line, or from a search field in the Help tab of the lower-right pane. (help() is a function in R, arguments to a function are passed in parentheses “()”) help(rnorm) (shorthand for the same thing) ?rnorm (what was the name of that again … ?) ?binom ## No documentation for &#39;binom&#39; in specified packages and libraries: ## you could try &#39;??binom&#39; ??binom (I see “Binomial” in the list of keywords…) ?Binomial (Alternatively: use the apropos() function. ?apropos apropos(&quot;med&quot;) # all functions that contain the string &quot;med&quot; ## [1] &quot;elNamed&quot; &quot;elNamed&lt;-&quot; &quot;median&quot; &quot;median.default&quot; ## [5] &quot;medpolish&quot; &quot;runmed&quot; apropos(&quot;^med&quot;) # all functions that begin with the string ## [1] &quot;median&quot; &quot;median.default&quot; &quot;medpolish&quot; apropos(&quot;med$&quot;) # all functions that end with the string ## [1] &quot;elNamed&quot; &quot;runmed&quot; If you need help on operators, place them in quotation marks. Try: ?&quot;+&quot; ?&quot;~&quot; ?&quot;[&quot; ?&quot;%in%&quot; That’s all fine, but you will soon notice that R’s help documentation is very technical and precise but not all that helpful for newcomers (who need the most help). To illustrate, open the help window for the function var(). ?var Here’s what you might look for: The Description section describes the function in general technical terms. The Usage section tells you what arguments are required (these don’t have defaults), what arguments have defaults, and what the defaults are, and whether additional arguments (“…”) are allowed. Often a function comes in several variants, you will find them here. The Arguments section provides detailed information . You should read it, especially regarding whether the arguments are single values, vectors, or other objects, and what effect missing arguments will have. The Details section might provide common usage and context information. It might also not. Often functions have crucial information buried in an innocuous note here. You really have to read and understand the Value section. It explains the output of the function (its returnvalue). The object a function returns could be a list, a matrix or something else (we’ll discuss these data types in detail elsewhere.). The value could also be an object that has special methods defined e.g. for plotting it. In that case, the object is formally a “list”, and its named “components” can be retrieved with the usual list syntax. If you look at the bottom of the help text, you will usually find examples of the function’s usage; these sometimes make matters more clear than the terse and principled help-text above. What you often won’t find: Clear commented, examples that relate to the most frequent use cases. Explanations why a particular function is done in a particular way (e.g. why the denominator is n-1 for sd() and var()). Notes on common errors: A (reasonably) exhaustive list of alternatives and related functions. There are usually some entries, but there is no guarantee that all alternatives are listed – especially if they are provided by an external package. Therefore, my first approach for R information is usually to Google for what interests me and this is often the quickest way to find working example code. R has a very large user base and it is becoming very rare that a reasonable question will not have a reasonable answer among the top three hits of a Google search. Also, as a result of a Google search, it may turn out that something can’t be done (easily) – and you won’t find things that can’t be done in the help system at all. You may want to include “r language” in your search terms, although Google is usually pretty good at figuring out what kind of “r” you are looking for, especially if your query includes a few terms vaguely related to statistics or programming. There is an active R-help mailing list to which you can post–or at least search the archives: your question probably has been asked and answered before. A number of SIGs (Special Interest Groups) exist for more specific discussions - e.g. for mac OS, geography, ecology etc. They are listed here. Most of the good responses these days are on stack overflow, discussion seems to be shifting to there from the R mailing list. Information on statistics questions can often be found or obtained from the CrossValidated forum of stackexchange. try this sample search on stackOverflow… try this sample search on CrossValidated… Rseek is a specialized Google search on R-related sites. Try “time series analysis” for an example. The bioconductor project has its own support site on the Web. If you want a quick and constructive answer from the R mailing list or stackoverflow, you must do a bit of homework first. If you ask your question well, you will get incredibly insightful and helpful responses, but you need to help the helpers to help you: Use the dput() function, perhaps combined with head() to create a small, reproducible dataset with which your problem can be reproduced or your question illustrated. Keep this as small as possible. Post that. Don’t post screenshots! Post minimal code that reproduces the problem with the data you have supplied. Together the code and data have to form an MWE – a minimal working example. People love to play with your code and get it to work, but they hate having to copy, paste, reformat or otherwise edit someone’s stuff just so they can answer their question. Don’t waste too much time on explaining what you did (since that didn’t work) - just enough to help your readers understand that you did indeed invest some effort in trying to solve the problem yourself. Spend your time to explain clearly what you want to achieve. Focus on the desired result - not on how to fix your algorithm; your algorithm may be the wrong mental model in the first place. Don’t post in HTML, be sure to post in plain text only. 5.4 Task 10 - reproducible example Read “How to write a reproducible example” and “How to make a great R reproducible example”. BTW: the same principles apply to questions you post on the course mailing list. 5.5 Self-evaluation Question 1 Is the apropos() command case-sensitive? Try it out: apropos(“^med”) apropos(“^MED”) 5.6 Notes 5.7 Further reading, links and resources If in doubt, ask! If anything about this learning unit is not clear to you, do not proceed blindly but ask for clarification. Post your question on the course mailing list: others are likely to have similar problems. Or send an email to your instructor. Author: Boris Steipe boris.steipe@utoronto.ca Created: 2017-08-05 Modified: 2018-05-04 Version: 1.0.1 Version history: 1.0.1 Maintenance 1.0 Completed to first live version 0.1 Material collected from previous tutorial 5.7.1 Updated Revision history Revision Author Date Message 5152496 Ruth Isserlin 2019-12-25 Fixed issue with task numbering because of a remove all elements call in the 2nd chapter fab47ae Ruth Isserlin 2019-12-24 initial check in of R basics book 5.7.2 Footnotes: "],["r-snytax.html", "Chapter 6 Basics of R syntax 6.1 Overview 6.2 Simple commands 6.3 Task 11 6.4 Task 12 6.5 Variables 6.6 Self-evaluation 6.7 Further reading, links and resources", " Chapter 6 Basics of R syntax (Simple commands and basic syntax, operators, variables, class, mode, and attributes) 6.1 Overview 6.1.1 Abstract: This unit discusses simple R commands and basic syntax, operators, and R objects (variables). 6.1.2 Objectives: This unit will: introduce basic operations of R syntax; provide examples for use of operators; discuss variable names. 6.1.3 Outcomes: After working through this unit you: can evaluate R expressions by typing them on the console; know how to write and debug complex R expressions that are deeply nested with parentheses; are able to avoid common issues when choosing variable names. 6.1.4 Deliverables: Time management: Before you begin, estimate how long it will take you to complete this unit. Then, record in your course journal: the number of hours you estimated, the number of hours you worked on the unit, and the amount of time that passed between start and completion of this unit. Journal: Document your progress in your Course Journal. Some tasks may ask you to include specific items in your journal. Don’t overlook these. Insights: If you find something particularly noteworthy about this unit, make a note in your insights! page. 6.1.5 Prerequisites RPR-Console (Console and scripts) RPR-Help (Getting help for R) RPR-Setup (Setup R to work with it) RPR-Installation (Installing R and RStudio) 6.2 Simple commands The R command line evaluates expressions. Expressions can contain constants, variables, operators and functions of the various datatypes that R recognizes. 6.2.1 Operators The common arithmetic operators are recognized in the usual way. 6.3 Task 11 Open an RStudio session and try the following operators on numbers: 5 5 + 3 5 + 1 / 2 # Think first: is this 3 or 5.5 3 * 2 + 1 3 * (2 + 1) 2^3 # Exponentiation 8 ^ (1/3) # Third root via exponentiation 7 %% 2 # Modulo operation (remainder of integer division) 7 %/% 2 # Integer division # Logical operators return TRUE or FALSE # Unary: TRUE FALSE ! TRUE # read carefully: the &quot;!&quot; (meaning &quot;not&quot;) is easily overlooked ! FALSE # Binary operators 1 == 2 1 != 2 1 &lt; 2 1 &gt; 2 1 &gt; 1 1 &gt;= 1 1 &lt; 1 1 &lt;= 1 # &amp; (means AND) TRUE &amp; TRUE TRUE &amp; FALSE FALSE &amp; FALSE # | (means OR) TRUE | TRUE TRUE | FALSE FALSE | FALSE # Predict what this will return !(FALSE | (! FALSE)) Given the expression shown below, the value of lastNum is 9: numbers &lt;- c(16, 20, 3, 5, 9) numbers lastNum &lt;- tail(numbers, 1) # explain what this does lastNum # Note: expressions in parentheses: # when we assign, e.g. ... numbers &lt;- sample(1:20, 5) # ... we can get the value of the vector &quot;numbers&quot; with ... print(numbers) # ... or just ... numbers # But we can also put the entire expression in parentheses, and when it is # evaluated, which results in the assignment, the value is also printed. (numbers &lt;- sample(1:20, 5)) # so: when you see parentheses around an entire expression, remember that all # the parentheses do is to perform some evaluation, and then print the # resulting object. I use this idiom lot for compactness in teaching code. # In general, you usually don&#39;t need this in scripts that you develop, but for # teaching I often need you to study the contents of a variable. 6.4 Task 12 Write R expressions for the following: To check whether lastNum is less than 6 or greater than 10 11 To check whether lastNum is in the interval [10, 20). (By the rules of mathematical notation this means 10 is included but 20 is not).12 To output TRUE if the following operation gives 213: * take lastNum * divide it by 7 * subtract the integer part and the first digit after the decimal point (hint: multiply by 10, then integer division by 1 gives you ... what) * multiply by 100 * integer divide by 1 * take the third root (Hints: use lots of parentheses and compare the final result to 2. To debug, select parts of the code and execute separately. If the console gets stuck because it is expecting a closing parenthesis, and all you see is the “+” sign, simply press to abort evaluation.) 6.5 Variables In order to store the results of expressions and computations, you can freely assign them to variables14. Variables are created by R whenever you first use them (i.e. space in memory is allocated to the variable and a value is stored in that space.) Variable names distinguish between upper case and lower case letters. There are a small number of reserved names that you are not allowed to redefine, and R syntax contains very small number of predefined constants, such as pi. However these constants can be overwritten - be careful: R will allow you to define pi &lt;- 3 but casually redefining the foundations of mathematics may lead to unintended consequences. Read more about variable names at: ?make.names ?reserved To assign a value to a constant, use the assignment operator &lt;-. This is the default way of assigning values in R. You could also use the = sign, but there are subtle differences. (See: ?“&lt;-”). There is a variant of the assignment operator &lt;&lt;- which is sometimes used inside functions. It assigns to a global context. This is possible, but not preferred since it generates a side effect of a function. Don’t do this. Just forget that &lt;&lt;- even exists. a &lt;- 5 a ## [1] 5 a + 3 ## [1] 8 b &lt;- 8 b ## [1] 8 a + b ## [1] 13 a == b # not assignment: equality test ## [1] FALSE a != b # not equal ## [1] TRUE a &lt; b # less than ## [1] TRUE Note that all of R’s data types (as well as functions and other objects) can be assigned to variables. There are very few syntactic restrictions on variable names (discussed eg. here) but this does not mean esoteric names are good. For the sake of your sanity, use names that express the meaning of the variable, and that are unique. Many R developers use dotted.variable.names, some people use the pothole_style, my personal preference is to write camelCaseNames. And while the single letters c f n s Q are syntactically valid variable names, they coincide with commands for the debugger browser and will execute debugger commands, rather than displaying variable values when you are debugging. Finally, try not to use variable names that are the same as parameter names in functions. Alas, you see this often in code, but such code can be hard to read because the semantics of the actual argument versus the parameter name becomes obscured. It’s just common sense really: don’t call different things by the same name. # I don&#39;t like... col &lt;- c(&quot;red&quot;, &quot;grey&quot;) hist(rnorm(200), col=col) # I prefer instead something like... stripes &lt;- c(&quot;red&quot;, &quot;grey&quot;) hist(rnorm(200), col=stripes) 6.6 Self-evaluation 6.7 Further reading, links and resources If in doubt, ask! If anything about this learning unit is not clear to you, do not proceed blindly but ask for clarification. Post your question on the course mailing list: others are likely to have similar problems. Or send an email to your instructor. Author: Boris Steipe boris.steipe@utoronto.ca Created: 2017-08-05 Modified: 2018-05-04 Version: 1.0.1 Version history: 1.0.1 Maintenance 1.0 Completed to first live version 0.1 Material collected from previous tutorial 6.7.1 Updated Revision history Revision Author Date Message 5152496 Ruth Isserlin 2019-12-25 Fixed issue with task numbering because of a remove all elements call in the 2nd chapter fab47ae Ruth Isserlin 2019-12-24 initial check in of R basics book 6.7.2 Footnotes: lastNum &lt; 6 | lastNum &gt; 10↩︎ lastNum &gt;= 10 &amp; lastNum &lt; 20↩︎ ((((9/7) - ((((9/7) * 10) %/% 1 )/10)) * 100) %/% 1 )^(1/3) == 2↩︎ We call these “variables” because of what function they perform in our code, they actually are R “objects”.↩︎ "],["r-scalars.html", "Chapter 7 R scalars and vectors 7.1 Overview 7.2 R Data types 7.3 Scalar data 7.4 Task 13 - scalars 7.5 Vectors 7.6 Subsetting by index 7.7 Excluding items through negative indexes 7.8 Subsetting by boolean vectors 7.9 Subsetting by name 7.10 “[” is an operator 7.11 Subsetting by name: 7.12 Task 14 - vectors 7.13 Vectorized operations 7.14 computing with two vectors of same length 7.15 Matrices and higher-dimensional objects 7.16 Task 15 - matrices 7.17 Self-evaluation 7.18 Further reading, links and resources", " Chapter 7 R scalars and vectors (Types of R objects: scalars, vectors and matrices) 7.1 Overview 7.1.1 Abstract: Introduction to vector objects in R: what are they, how are they created, how can they be subset? 7.1.2 Objectives: This unit will: introduce scalars, vectors and matrices; demonstrate vectorized operations; teach various ways of subsetting; 7.1.3 Outcomes: After working through this unit you: can create vectors by assignment from sequences or using the c(); are familar with subsetting by index, name, and boolean vectors; can subset elements, ranges, and slices from vectors and matrices; can combine objects with c(), rbind(), or cbind(). 7.1.4 Deliverables: Time management: Before you begin, estimate how long it will take you to complete this unit. Then, record in your course journal: the number of hours you estimated, the number of hours you worked on the unit, and the amount of time that passed between start and completion of this unit. Journal: Document your progress in your Course Journal. Some tasks may ask you to include specific items in your journal. Don’t overlook these. Insights: If you find something particularly noteworthy about this unit, make a note in your insights! page. 7.1.5 Prerequisites RPR-Syntax_basics (Basics of R syntax) 7.2 R Data types R objects can be composed of different kinds of data according to the type and number of “atomic” values they contain: Scalar items are single values; Vectors are ordered sequences of scalars, they must all have the same “data type” (e.g. numeric, logical, character …); Matrices are vectors for which one or more “dimension(s)” have been defined; “Data frames”” are spreadsheet-like objects, their columns are like vectors and all columns must have the same length, but within one data frame, columns can have different data types. They are the most commonly used type of object to hold data; Lists are the most general collection of data items, the can contain items of any type and kind, including matrices, functions, data frames, and other lists. 7.3 Scalar data Scalars are single numbers, the “atomic” parts of more complex datatypes. Of course we can work with single numbers in R, but under the hood they are actually vectors of length 1. (More on vectors in the next section). To create a scalar object, simply assign some value to its name. define a scalar by assignment x &lt;- pi its value is … x ## [1] 3.141593 its length is … length(x) ## [1] 1 it is actually a vector, and its first element is … x[1] ## [1] 3.141593 a second element does not exist NA: Not Available x[2] ## [1] NA Here are some remarks on the types of scalars R uses, and on coercion between types, i.e. casting one datatype into another. The following scalar types are supported: Boolean constants: TRUE and FALSE. This type has the “mode” logical; Integers, floats (floating point numbers) and complex numbers. These types have the mode numeric; Strings. These have the mode character. Other modes exist, such as list, function and expression, all of which can be combined into complex objects. The function mode() returns the mode of an object and typeof() returns its type. Also class() tells you what class it belongs to. typeof(TRUE) ## [1] &quot;logical&quot; class(3L) ## [1] &quot;integer&quot; mode(print) ## [1] &quot;function&quot; I have combined these information functions into a single function, objectInfo() which gets loaded and defined when you execute the init() function of the BasicSetup project, so you can explore objects in more detail. We can use objectInfo() to explore how R objects are made up, by handing various expressions as arguments to the function. Many of these you may not yet recognize … bear with it though: 7.4 Task 13 - scalars Load the R-Exercise_BasicSetup project in RStudio if you don’t already have it open. Type init() as instructed after the project has loaded. Continue below. Let’s have a brief look at the function itself: typing a function name without its parentheses returns the source code for the function: objectInfo ## function (x) ## { ## cat(&quot;object contents:&quot;) ## print(x, digits = 22) ## cat(&quot;\\nstructure of object:\\n&quot;) ## str(x) ## if (!is.list(x)) { ## cat(&quot;\\nmode: &quot;, mode(x), &quot;\\n&quot;) ## cat(&quot;typeof: &quot;, typeof(x), &quot;\\n&quot;) ## cat(&quot;class: &quot;, class(x), &quot;\\n&quot;) ## } ## if (!is.null(attributes(x))) { ## cat(&quot;\\nattributes:\\n&quot;) ## attributes(x) ## } ## } Try out the below # Various objects: #Scalars: objectInfo( 3.0 ) # Double precision floating point number objectInfo( 3.0e0 ) # Same value, exponential notation objectInfo( 3 ) # Note: integers are double precision floats by default. objectInfo( 3L ) # If we really want an integer, we must use R&#39;s # special integer notation ... objectInfo( as.integer(3) ) # or explicitly &quot;coerce&quot; to type integer... # Coercions: For each of these, first think what result you would expect: objectInfo( as.character(3) ) # Forcing the number to be interpreted as a character. objectInfo( as.numeric(&quot;3&quot;) ) # character as numeric objectInfo( as.numeric(&quot;3.141592653&quot;) ) # string as numeric. Where do the # non-zero digits at the end come from? objectInfo( as.numeric(pi) ) # not a string, but a predefined constant objectInfo( as.numeric(&quot;pi&quot;) ) # another string as numeric ... Ooops - # why the warning? objectInfo( as.complex(1) ) objectInfo( as.logical(0) ) objectInfo( as.logical(1) ) objectInfo( as.logical(-1) ) objectInfo( as.logical(pi) ) # any non-zero number is TRUE ... objectInfo( as.logical(&quot;pie&quot;) ) # ... but not non-numeric types. # NA means &quot;Not Available&quot;. objectInfo( as.character(pi) ) # Interesting: the conversion eats digits. objectInfo( Inf ) # Larger than the largest representable number objectInfo( -Inf ) # ... or smaller objectInfo( NaN ) # &quot;Not a Number&quot; is numeric objectInfo( NA ) # &quot;Not Available&quot; - i.e. missing value is # logical by default # NULL objectInfo( NULL ) # NULL is nothing. Not 0, not NaN, # not FALSE - nothing. NULL is the value that is returned # by expressions or functions when the result is # undefined and nothing more can be said about it. objectInfo( as.factor(&quot;M&quot;) ) # factor objectInfo( Sys.time() ) # time objectInfo( letters ) # inbuilt character vector objectInfo( LETTERS ) # same objectInfo( 1:4 ) # numeric vector objectInfo( matrix(1:4, nrow=2)) # numeric matrix objectInfo( data.frame(arabic = 1:3, # data frame roman = c(&quot;I&quot;, &quot;II&quot;, &quot;III&quot;), stringsAsFactors = FALSE)) objectInfo( list(arabic = 1:7, roman = c(&quot;I&quot;, &quot;II&quot;, &quot;III&quot;), chinese = c(&quot;一&quot;, &quot;二&quot;, &quot;三&quot;, &quot;四&quot;))) # list # Expressions: objectInfo( 3 &gt; 5 ) # Note: any combination of two variables via the logical # operators ! == != &gt; &lt; &gt;= &lt;= | || &amp; and &amp;&amp; is a # logical expression, and evaluates to TRUE or FALSE. objectInfo( 3 &lt; 5 ) objectInfo( 1:6 &gt; 4 ) # these are &quot;vectorized&quot; operators objectInfo( a ~ b ) # a formula objectInfo( objectInfo ) # the function itself Sometimes (but rarely) you may run into a distinction that R makes regarding integers and floating point numbers. By default, if you specify e.g. the number 2 in your code, it is stored as a floating point number. But if the numbers are generated e.g. from a range operator as in 1:2 they are integers! This can give rise to confusion as in the following example: a &lt;- 7 b &lt;- 6:7 str(a) # num 7 ## num 7 str(b) # int [1:2] 6 7 ## int [1:2] 6 7 a == b[2] # TRUE ## [1] TRUE identical(b[2], a) # FALSE ! Not identical! Why? ## [1] FALSE # (see the str() results above.) # If you need to be sure that a number is an # integer, write it with an &quot;L&quot; after the number: c &lt;- 7L str(c) # int 7 ## int 7 identical(b[2], c) # TRUE ## [1] TRUE 7.5 Vectors Since we (almost) never do statistics on scalars, R obviously needs ways to handle collections of data items. In its simplest form such a collection is a vector: an ordered list of items of the same type. * Vectors are created from scratch with the c() function which concatenates individual items into a vector, or with various sequencing functions. * Vectors have properties, such as length; * individual items in vectors can be combined in useful ways. * It’s worth repeating: all elements of a vector must be of the same type. If they are not, they are silently(!) coerced to the most general type (which is often character). (The actual hierarchy for coercion is raw &lt; logical &lt; integer &lt; double &lt; complex &lt; character &lt; list ). The c() function concatenates elements into a vector c(2, 4, 6) ## [1] 2 4 6 Create a vector and list its contents and length: f &lt;- c(1, 1, 3, 5, 8, 13, 21) f ## [1] 1 1 3 5 8 13 21 length(f) ## [1] 7 Often, for teaching code, I want to demonstrate the contents of an object after assigning it. I can simply wrap the assignment into parentheses to achieve that. Parentheses return the value of whatever they enclose. So … assigns 17 to the variable “a”. But this happens silently. a &lt;- 17 However, returns the result of the assignment. I will use this idiom often. ( a &lt;- 17 ) ## [1] 17 ( myVec &lt;- c(1, 1, 3, 5, 8, 13, 21, 34, 55, 89) ) ## [1] 1 1 3 5 8 13 21 34 55 89 7.5.1 Coercion: all elements of vectors must be of the same type # trying to get a vector with mixed types ... (mixed_type &lt;- c(1, 2.0, &quot;3&quot;, TRUE)) ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;TRUE&quot; class(mixed_type) ## [1] &quot;character&quot; … shows that all elements are silently being coerced to character. The emphasis is on silently. This might be unexpected, for example if you are reading numeric data from a text-file into a vector but someone has entered a ” ” for a missing value … then everything is characterified. Nasty. There are various ways to subset (retrieve) specific values from a vector; this is important. 7.6 Subsetting by index Extracting by index: * “1” is first element, not 0. * head() gets the first n elements * length() is the index of the last element. * tail() get the last n elements myVec[1] ## [1] 1 head(myVec, 1) # same thing ## [1] 1 myVec[length(myVec)] ## [1] 89 tail(myVec, 1) # same thing ## [1] 89 With a vector of indices: * This is the range operator 1:4 ## [1] 1 2 3 4 using the range operator (it generates a sequence and returns it in a vector) myVec[1:4] ## [1] 1 1 3 5 same thing, backwards myVec[4:1] ## [1] 5 3 1 1 The seq() function is a flexible, generic way to generate sequences seq(from=2, to=6, by=2) ## [1] 2 4 6 seq(2, 6, 2) # Same thing: arguments in default order ## [1] 2 4 6 myVec[seq(2, 6, 2)] ## [1] 1 5 13 since a scalar is a vector of length 1, does this work? 5[1] Using an index vector with positive indices the elements of index vectors must be valid indices of the target vector. The index vector can be of any length. a &lt;- c(1, 3, 4, 1) myVec[a] # In this case, four elements are retrieved from f[] ## [1] 1 3 5 1 7.7 Excluding items through negative indexes Negative indices omit elements: using an index vector with negative indices # If elements of index vectors are negative integers, # the corresponding elements are excluded. ( a &lt;- -(1:4) ) # Note that this is NOT the same as -1:4 ## [1] -1 -2 -3 -4 ( a &lt;- -(1:4) ) ## [1] -1 -2 -3 -4 myVec[a] # Here, the first four elements are omitted from myVec[] ## [1] 8 13 21 34 55 89 myVec[-((length(myVec)-3):length(myVec))] # Here, the last four elements are omitted ## [1] 1 1 3 5 8 13 7.8 Subsetting by boolean vectors A logical expression operating on the target vector returns a vector of logical elements. It has the same length as the target vector. myVec &gt; 4 ## [1] FALSE FALSE FALSE TRUE TRUE TRUE TRUE TRUE TRUE TRUE We can use this logical vector to extract only elements for which the logical expression evaluates as TRUE. This is also called “filtering”. myVec[myVec &gt; 4]; ## [1] 5 8 13 21 34 55 89 Note: the logical vector is aligned with the elements of the original vector. You can’t retrieve elements more than once, as you could with index vectors. If the logical vector is shorter than its target it is “recycled” to the full length. (1:20)[c(TRUE, FALSE)] # odd numbers, but how and why? ## [1] 1 3 5 7 9 11 13 15 17 19 7.9 Subsetting by name If the vector has named elements, vectors of names can be used exactly like index vectors: summary(myVec)[&quot;Median&quot;] ## Median ## 10.5 summary(myVec)[c(&quot;Max&quot;, &quot;Min&quot;)] # Oooops - I mistyped. But you can fix the expression, right? ## &lt;NA&gt; &lt;NA&gt; ## 7.10 “[” is an operator Some more thoughts about “[” “[” is not just a special character, it is an operator. It operates on whatever it is attached to on the left. ?&quot;[&quot; # help is available ... We have attached “[” to vectors above, but we can also attach it directly to functions or other expressions. For example, the summary() function returns some basic statistics of a vector: summary(myVec) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 1.00 3.50 10.50 23.00 30.75 89.00 This is a vector of six numbers: length(summary(myVec)) ## [1] 6 We can extract e.g. the median like so: summary(myVec)[3] ## Median ## 10.5 … or the boundaries of the interquartile range: summary(myVec)[c(2, 5)] ## 1st Qu. 3rd Qu. ## 3.50 30.75 Note that the elements that summary() returns are “named”. “Names” are attributes. objectInfo(summary(f)) ## object contents: Min. 1st Qu. Median ## 1.000000000000000000000 2.000000000000000000000 5.000000000000000000000 ## Mean 3rd Qu. Max. ## 7.428570999999999813213 10.500000000000000000000 21.000000000000000000000 ## ## structure of object: ## &#39;summaryDefault&#39; Named num [1:6] 1 2 5 7.43 10.5 ... ## - attr(*, &quot;names&quot;)= chr [1:6] &quot;Min.&quot; &quot;1st Qu.&quot; &quot;Median&quot; &quot;Mean&quot; ... ## ## mode: numeric ## typeof: double ## class: summaryDefault table ## ## attributes: ## $names ## [1] &quot;Min.&quot; &quot;1st Qu.&quot; &quot;Median&quot; &quot;Mean&quot; &quot;3rd Qu.&quot; &quot;Max.&quot; ## ## $class ## [1] &quot;summaryDefault&quot; &quot;table&quot; The names() function can retrieve (or set) names: names(summary(myVec)) ## [1] &quot;Min.&quot; &quot;1st Qu.&quot; &quot;Median&quot; &quot;Mean&quot; &quot;3rd Qu.&quot; &quot;Max.&quot; … which brings us to yet another way to extract elements from Vectors: 7.11 Subsetting by name: Extending vectors: Vectors are not immutable. They can grow and shrink as required. ( x &lt;- 1:3 ) ## [1] 1 2 3 length(x) ## [1] 3 x[4] &lt;- 4; x ## [1] 1 2 3 4 length(x) ## [1] 4 You can add to any index you would like. R will fill the intermediary spots with NA x[7] &lt;- 7; x ## [1] 1 2 3 4 NA NA 7 length(x) ## [1] 7 ( x &lt;- x[-(5:6)] ) ## [1] 1 2 3 4 7 length(x) ## [1] 5 Example : extending the Fibonacci series for three steps. ( myVec &lt;- c(myVec, myVec[length(myVec)-1] + myVec[length(myVec)]) ) ## [1] 1 1 3 5 8 13 21 34 55 89 144 ( myVec &lt;- c(myVec, myVec[length(myVec)-1] + myVec[length(myVec)]) ) ## [1] 1 1 3 5 8 13 21 34 55 89 144 233 ( myVec &lt;- c(myVec, myVec[length(myVec)-1] + myVec[length(myVec)]) ) ## [1] 1 1 3 5 8 13 21 34 55 89 144 233 377 7.12 Task 14 - vectors Think: How does this work? What numbers are we adding here and why does the result end up in the vector? 7.13 Vectorized operations Many operations on vectors are by default performed for every element of the vector, and R computes them very efficiently. These are called “vectorized” operations and definitely should be used whenever possible, rather than loops or other explicit iterations. For example: myVec ## [1] 1 1 3 5 8 13 21 34 55 89 144 233 377 myVec + 1 ## [1] 2 2 4 6 9 14 22 35 56 90 145 234 378 log(myVec) ## [1] 0.000000 0.000000 1.098612 1.609438 2.079442 2.564949 3.044522 3.526361 ## [9] 4.007333 4.488636 4.969813 5.451038 5.932245 myVec * 2 ## [1] 2 2 6 10 16 26 42 68 110 178 288 466 754 7.14 computing with two vectors of same length the Fibonacci numbers you have defined above myVec ## [1] 1 1 3 5 8 13 21 34 55 89 144 233 377 like myVec, but omitting the first element ( a &lt;- myVec[-1] ) ## [1] 1 3 5 8 13 21 34 55 89 144 233 377 like f, but shortened by the last element ( b &lt;- myVec[1:(length(myVec)-1)] ) ## [1] 1 1 3 5 8 13 21 34 55 89 144 233 the “golden ratio”, phi (~1.61803 or (1+sqrt(5))/2 ),an irrational number, is approximated by the ratio of two consecutive Fibonacci numbers. c &lt;- a / b abs(c - ((1+sqrt(5))/2)) # Calculating the error of the approximation, element by element ## [1] 6.180340e-01 1.381966e+00 4.863268e-02 1.803399e-02 6.966011e-03 ## [6] 2.649373e-03 1.013630e-03 3.869299e-04 1.478294e-04 5.646066e-05 ## [11] 2.156681e-05 8.237677e-06 When a number is not a single number: One of the “warts” of R is that some functions substitute a range when they receive a vector of length one. Most everyone agrees this is pretty bad. This behaviour was introduced when someone sometime long ago thought it would be nifty to save two keystrokes. This has caused countless errors, hours of frustration and probably hundreds of undiscovered bugs instead. Today we wouldn’t write code like that anymore (I hope), but the community believes that since it’s been around for so long, it would probably break more things if it’s changed. Two functions to watch out for are sample() and seq(); other functions include diag() and runif(). Consider: x &lt;- 8; sample(6:x) x &lt;- 7; sample(6:x) x &lt;- 6; sample(6:x) # Oi! also consider x &lt;- 6:8; seq(x) x &lt;- 6:7; seq(x) x &lt;- 6:6; seq(x) # Oi vay! Wherever this misbehaviour is a possibility - i.e. when the number of elements to sample from is variable and could be just one, for example in some simulation code - you can write a replacement function like so… safeSample &lt;- function(x, size, …) { # Replace the sample() function to ensure sampling from a single # value returns that value. # Respect additional arguments if present. if (length(x) == 1 &amp;&amp; is.numeric(x) &amp;&amp; x &gt; 0) { if (missing(size)) size &lt;- 1 return(rep(x, size)) } else { return(sample(x, size, …)) } } Don’t be discouraged though: such warts are rare in R. 7.15 Matrices and higher-dimensional objects If we need to operate with several vectors, or multi-dimensional data, we make use of matrices or more generally k-dimensional arrays. Matrix operations are very similar to vector operations, in fact a matrix actually is a vector for which the number of rows and columns have been defined. Thus matrices inherit the basic limitation of vectors: all elements have to be of the same type. The most basic way to define matrix rows and columns is to use the dim() function and specify the size of each dimension. Consider: ( a &lt;- 1:12 ) ## [1] 1 2 3 4 5 6 7 8 9 10 11 12 dim(a) &lt;- c(2,6) a ## [,1] [,2] [,3] [,4] [,5] [,6] ## [1,] 1 3 5 7 9 11 ## [2,] 2 4 6 8 10 12 dim(a) &lt;- c(4,3) a ## [,1] [,2] [,3] ## [1,] 1 5 9 ## [2,] 2 6 10 ## [3,] 3 7 11 ## [4,] 4 8 12 dim(a) &lt;- c(2,2,3) a ## , , 1 ## ## [,1] [,2] ## [1,] 1 3 ## [2,] 2 4 ## ## , , 2 ## ## [,1] [,2] ## [1,] 5 7 ## [2,] 6 8 ## ## , , 3 ## ## [,1] [,2] ## [1,] 9 11 ## [2,] 10 12 dim() also tells you the number of rows resp. columns a matrix has. For example: dim(a) # returns the dimensions of a in a vector dim(a)[3] # only the size of the third dimension of a If you have a two-dimensional matrix, the function nrow() and ncol() will also give you the number of rows and columns, respectively. Obviously, dim(a)[1] is the same as nrow(a). As an alternative to dim(), matrices can be defined using the matrix() or array() functions (see there), or “glued” together from vectors by rows or columns, using the rbind() or cbind() functions respectively: ( a &lt;- 1:4 ) ## [1] 1 2 3 4 ( b &lt;- 5:8 ) ## [1] 5 6 7 8 ( m1 &lt;- rbind(a, b) ) ## [,1] [,2] [,3] [,4] ## a 1 2 3 4 ## b 5 6 7 8 ( m2 &lt;- cbind(a, b) ) ## a b ## [1,] 1 5 ## [2,] 2 6 ## [3,] 3 7 ## [4,] 4 8 ( m &lt;- cbind(m2, c = 9:12) ) # naming a column &quot;c&quot; while cbind()&#39;ing it ## a b c ## [1,] 1 5 9 ## [2,] 2 6 10 ## [3,] 3 7 11 ## [4,] 4 8 12 “Subsetting” (retrieving) individual elements or slices from matrices is simply done by specifying the appropriate indices, where a missing index indicates that the entire row or column is to be retrieved. 7.16 Task 15 - matrices Explore how you extract rows or columns from a matrix by specifying them. Within the square brackets the order is [, &lt;columns&lt;] m[1,] # first row m[, 2] # second column m[3, 2] # element at row == 3, column == 2 m[3:4, 1:2] # submatrix: rows 3 to 4 and columns 1 to 2 Note that R has numerous functions to compute with matrices, such as transposition, multiplication, inversion, calculating eigenvalues and eigenvectors and much more. 7.17 Self-evaluation Question 1 : Within the square brackets of a matrix the order is [, ], but what about slices of a 3D matrix? Is it [, , ] or [, , ]? Answer: Just try - 15 x &lt;- 1:27 dim(x) &lt;- c(3, 3, 3) x x[2, 1, 1] # 2 x[1, 1, 2] # 10 7.18 Further reading, links and resources If in doubt, ask! If anything about this learning unit is not clear to you, do not proceed blindly but ask for clarification. Post your question on the course mailing list: others are likely to have similar problems. Or send an email to your instructor. Author: Boris Steipe boris.steipe@utoronto.ca Created: 2017-08-05 Modified: 2018-05-04 Version: 1.0.1 Version history: 1.0.1 Maintenance 1.0 Completed to first live version 0.1 Material collected from previous tutorial 7.18.1 Updated Revision history Revision Author Date Message 5152496 Ruth Isserlin 2019-12-25 Fixed issue with task numbering because of a remove all elements call in the 2nd chapter fab47ae Ruth Isserlin 2019-12-24 initial check in of R basics book 7.18.2 Footnotes: and this means [, &lt;columns&lt;, ] is correct.↩︎ "],["r-data-frames.html", "Chapter 8 Data frames 8.1 Overview 8.2 Data frames 8.3 Task 16 - Basic operations 8.4 Basic operations 8.5 Task 17 - modify data frame 8.6 Self-evaluation 8.7 Further reading, links and resources", " Chapter 8 Data frames (R data frames) 8.1 Overview 8.1.1 Abstract: Introduction to data frames: how to create, and modify them and how to retrieve data. 8.1.2 Objectives: This unit will: introduce R data frames; cover a number of basic operations. 8.1.3 Outcomes: After working through this unit you: know how to create and manipulate data frames; can extract rows, columns, and append new data rows; 8.1.4 Deliverables: Time management: Before you begin, estimate how long it will take you to complete this unit. Then, record in your course journal: the number of hours you estimated, the number of hours you worked on the unit, and the amount of time that passed between start and completion of this unit. Journal: Document your progress in your Course Journal. Some tasks may ask you to include specific items in your journal. Don’t overlook these. Insights: If you find something particularly noteworthy about this unit, make a note in your insights! page. 8.1.5 Prerequisites RPR-Objects-Vectors (R scalars and vectors) 8.2 Data frames 8.3 Task 16 - Basic operations Load the R-Exercise_BasicSetup project in RStudio if you don’t already have it open. Type init() as instructed after the project has loaded. Continue below. Data frames are probably the most important type of data object for bioinformatics in R; they emulate our mental model of data in a spreadsheet and can be used to implement entity-relationship datamodels. Usually the result of reading external data from an input file is a data frame. The file below is included with the R-Exercise-BasicSetup project files - it is called plasmidData.tsv, and you can click on it in the Files Pane to open and inspect it. This data set uses tabs as column separators and it has a header line. Similar files can be exported from Excel or other spreadsheet programs. Read this as a data frame as follows: ( plasmidData &lt;- read.table( file.path(&quot;data_files&quot;,&quot;plasmidData.tsv&quot;), sep=&quot;\\t&quot;, header=TRUE, stringsAsFactors = FALSE) ) ## Name Size Marker Ori Sites ## 1 pUC19 2686 Amp ColE1 EcoRI, SacI, SmaI, BamHI, XbaI, PstI, HindIII ## 2 pBR322 4361 Amp, Tet ColE1 EcoRI, ClaI, HindIII ## 3 pACYC184 4245 Tet, Cam p15A ClaI, HindIII objectInfo(plasmidData) ## object contents: Name Size Marker Ori Sites ## 1 pUC19 2686 Amp ColE1 EcoRI, SacI, SmaI, BamHI, XbaI, PstI, HindIII ## 2 pBR322 4361 Amp, Tet ColE1 EcoRI, ClaI, HindIII ## 3 pACYC184 4245 Tet, Cam p15A ClaI, HindIII ## ## structure of object: ## &#39;data.frame&#39;: 3 obs. of 5 variables: ## $ Name : chr &quot;pUC19&quot; &quot;pBR322&quot; &quot;pACYC184&quot; ## $ Size : int 2686 4361 4245 ## $ Marker: chr &quot;Amp&quot; &quot;Amp, Tet&quot; &quot;Tet, Cam&quot; ## $ Ori : chr &quot;ColE1&quot; &quot;ColE1&quot; &quot;p15A&quot; ## $ Sites : chr &quot;EcoRI, SacI, SmaI, BamHI, XbaI, PstI, HindIII&quot; &quot;EcoRI, ClaI, HindIII&quot; &quot;ClaI, HindIII&quot; ## ## attributes: ## $names ## [1] &quot;Name&quot; &quot;Size&quot; &quot;Marker&quot; &quot;Ori&quot; &quot;Sites&quot; ## ## $class ## [1] &quot;data.frame&quot; ## ## $row.names ## [1] 1 2 3 Note the argument stringsAsFactors = FALSE. If this is TRUE instead, R will convert all strings in the input to factors and this may lead to problems. Make it a habit to turn this behaviour off, you can always turn a column of strings into factors when you actually mean to have factors. You can view the data frame contents by clicking on the spreadsheet icon behind its name in the Environment Pane. 8.4 Basic operations Here are some basic operations with the data frame. Try them and experiment. If you break it by mistake, you can just recreate it by reading the source file again: use column 1 as rownames rownames(plasmidData) &lt;- plasmidData[ , 1] nrow(plasmidData) ## [1] 3 ncol(plasmidData) ## [1] 5 objectInfo(plasmidData) ## object contents: Name Size Marker Ori ## pUC19 pUC19 2686 Amp ColE1 ## pBR322 pBR322 4361 Amp, Tet ColE1 ## pACYC184 pACYC184 4245 Tet, Cam p15A ## Sites ## pUC19 EcoRI, SacI, SmaI, BamHI, XbaI, PstI, HindIII ## pBR322 EcoRI, ClaI, HindIII ## pACYC184 ClaI, HindIII ## ## structure of object: ## &#39;data.frame&#39;: 3 obs. of 5 variables: ## $ Name : chr &quot;pUC19&quot; &quot;pBR322&quot; &quot;pACYC184&quot; ## $ Size : int 2686 4361 4245 ## $ Marker: chr &quot;Amp&quot; &quot;Amp, Tet&quot; &quot;Tet, Cam&quot; ## $ Ori : chr &quot;ColE1&quot; &quot;ColE1&quot; &quot;p15A&quot; ## $ Sites : chr &quot;EcoRI, SacI, SmaI, BamHI, XbaI, PstI, HindIII&quot; &quot;EcoRI, ClaI, HindIII&quot; &quot;ClaI, HindIII&quot; ## ## attributes: ## $names ## [1] &quot;Name&quot; &quot;Size&quot; &quot;Marker&quot; &quot;Ori&quot; &quot;Sites&quot; ## ## $class ## [1] &quot;data.frame&quot; ## ## $row.names ## [1] &quot;pUC19&quot; &quot;pBR322&quot; &quot;pACYC184&quot; assign one row to a variable. This is also a data frame! One row. It has to be, because it contains elements of type chr and of type int! x &lt;- plasmidData[2, ] objectInfo(x) ## object contents: Name Size Marker Ori Sites ## pBR322 pBR322 4361 Amp, Tet ColE1 EcoRI, ClaI, HindIII ## ## structure of object: ## &#39;data.frame&#39;: 1 obs. of 5 variables: ## $ Name : chr &quot;pBR322&quot; ## $ Size : int 4361 ## $ Marker: chr &quot;Amp, Tet&quot; ## $ Ori : chr &quot;ColE1&quot; ## $ Sites : chr &quot;EcoRI, ClaI, HindIII&quot; ## ## attributes: ## $names ## [1] &quot;Name&quot; &quot;Size&quot; &quot;Marker&quot; &quot;Ori&quot; &quot;Sites&quot; ## ## $row.names ## [1] &quot;pBR322&quot; ## ## $class ## [1] &quot;data.frame&quot; retrieve one row: different syntax, same thing plasmidData[&quot;pBR322&quot;, ] ## Name Size Marker Ori Sites ## pBR322 pBR322 4361 Amp, Tet ColE1 EcoRI, ClaI, HindIII retrieve one column - two different methods plasmidData[ , 2] ## [1] 2686 4361 4245 plasmidData[ , &quot;Size&quot;] ## [1] 2686 4361 4245 remove one row plasmidData &lt;- plasmidData[-2, ] objectInfo(plasmidData) ## object contents: Name Size Marker Ori ## pUC19 pUC19 2686 Amp ColE1 ## pACYC184 pACYC184 4245 Tet, Cam p15A ## Sites ## pUC19 EcoRI, SacI, SmaI, BamHI, XbaI, PstI, HindIII ## pACYC184 ClaI, HindIII ## ## structure of object: ## &#39;data.frame&#39;: 2 obs. of 5 variables: ## $ Name : chr &quot;pUC19&quot; &quot;pACYC184&quot; ## $ Size : int 2686 4245 ## $ Marker: chr &quot;Amp&quot; &quot;Tet, Cam&quot; ## $ Ori : chr &quot;ColE1&quot; &quot;p15A&quot; ## $ Sites : chr &quot;EcoRI, SacI, SmaI, BamHI, XbaI, PstI, HindIII&quot; &quot;ClaI, HindIII&quot; ## ## attributes: ## $names ## [1] &quot;Name&quot; &quot;Size&quot; &quot;Marker&quot; &quot;Ori&quot; &quot;Sites&quot; ## ## $row.names ## [1] &quot;pUC19&quot; &quot;pACYC184&quot; ## ## $class ## [1] &quot;data.frame&quot; add it back at the end plasmidData &lt;- rbind(plasmidData, x) objectInfo(plasmidData) ## object contents: Name Size Marker Ori ## pUC19 pUC19 2686 Amp ColE1 ## pACYC184 pACYC184 4245 Tet, Cam p15A ## pBR322 pBR322 4361 Amp, Tet ColE1 ## Sites ## pUC19 EcoRI, SacI, SmaI, BamHI, XbaI, PstI, HindIII ## pACYC184 ClaI, HindIII ## pBR322 EcoRI, ClaI, HindIII ## ## structure of object: ## &#39;data.frame&#39;: 3 obs. of 5 variables: ## $ Name : chr &quot;pUC19&quot; &quot;pACYC184&quot; &quot;pBR322&quot; ## $ Size : int 2686 4245 4361 ## $ Marker: chr &quot;Amp&quot; &quot;Tet, Cam&quot; &quot;Amp, Tet&quot; ## $ Ori : chr &quot;ColE1&quot; &quot;p15A&quot; &quot;ColE1&quot; ## $ Sites : chr &quot;EcoRI, SacI, SmaI, BamHI, XbaI, PstI, HindIII&quot; &quot;ClaI, HindIII&quot; &quot;EcoRI, ClaI, HindIII&quot; ## ## attributes: ## $names ## [1] &quot;Name&quot; &quot;Size&quot; &quot;Marker&quot; &quot;Ori&quot; &quot;Sites&quot; ## ## $row.names ## [1] &quot;pUC19&quot; &quot;pACYC184&quot; &quot;pBR322&quot; ## ## $class ## [1] &quot;data.frame&quot; add a new row from scratch: plasmidData &lt;- rbind(plasmidData, data.frame(Name = &quot;pMAL-p5x&quot;, Size = 5752, Marker = &quot;Amp&quot;,Ori = &quot;pMB1&quot;, Sites = &quot;SacI, AvaI, ..., HindIII&quot;, stringsAsFactors = FALSE)) objectInfo(plasmidData) ## object contents: Name Size Marker Ori ## pUC19 pUC19 2686 Amp ColE1 ## pACYC184 pACYC184 4245 Tet, Cam p15A ## pBR322 pBR322 4361 Amp, Tet ColE1 ## 1 pMAL-p5x 5752 Amp pMB1 ## Sites ## pUC19 EcoRI, SacI, SmaI, BamHI, XbaI, PstI, HindIII ## pACYC184 ClaI, HindIII ## pBR322 EcoRI, ClaI, HindIII ## 1 SacI, AvaI, ..., HindIII ## ## structure of object: ## &#39;data.frame&#39;: 4 obs. of 5 variables: ## $ Name : chr &quot;pUC19&quot; &quot;pACYC184&quot; &quot;pBR322&quot; &quot;pMAL-p5x&quot; ## $ Size : num 2686 4245 4361 5752 ## $ Marker: chr &quot;Amp&quot; &quot;Tet, Cam&quot; &quot;Amp, Tet&quot; &quot;Amp&quot; ## $ Ori : chr &quot;ColE1&quot; &quot;p15A&quot; &quot;ColE1&quot; &quot;pMB1&quot; ## $ Sites : chr &quot;EcoRI, SacI, SmaI, BamHI, XbaI, PstI, HindIII&quot; &quot;ClaI, HindIII&quot; &quot;EcoRI, ClaI, HindIII&quot; &quot;SacI, AvaI, ..., HindIII&quot; ## ## attributes: ## $names ## [1] &quot;Name&quot; &quot;Size&quot; &quot;Marker&quot; &quot;Ori&quot; &quot;Sites&quot; ## ## $row.names ## [1] &quot;pUC19&quot; &quot;pACYC184&quot; &quot;pBR322&quot; &quot;1&quot; ## ## $class ## [1] &quot;data.frame&quot; 8.5 Task 17 - modify data frame The rowname of the new row of plasmidData is now “1”. It should be “pMAL-p5x”. Fix this. 8.6 Self-evaluation 8.7 Further reading, links and resources If in doubt, ask! If anything about this learning unit is not clear to you, do not proceed blindly but ask for clarification. Post your question on the course mailing list: others are likely to have similar problems. Or send an email to your instructor. Author: Boris Steipe boris.steipe@utoronto.ca Created: 2017-08-05 Modified: 2018-05-05 Version: 1.0.1 Version history: 1.0.1 Maintenance 1.0 Completed to first live version 0.1 Material collected from previous tutorial 8.7.1 Updated Revision history Revision Author Date Message 5152496 Ruth Isserlin 2019-12-25 Fixed issue with task numbering because of a remove all elements call in the 2nd chapter fab47ae Ruth Isserlin 2019-12-24 initial check in of R basics book 8.7.2 Footnotes: "],["r-lists.html", "Chapter 9 Lists 9.1 Overview 9.2 Lists 9.3 Task 18 9.4 Task 19 9.5 Self-evaluation 9.6 Further reading, links and resources", " Chapter 9 Lists (R Lists) 9.1 Overview 9.1.1 Abstract: Introduction to R list data types: properties, how to create, and modify them and how to retrieve data. 9.1.2 Objectives: This unit will: introduce R lists; cover a number of basic operations. 9.1.3 Outcomes: After working through this unit you: know how to create and manipulate lists; can extract items from lists. 9.1.4 Deliverables: Time management: Before you begin, estimate how long it will take you to complete this unit. Then, record in your course journal: the number of hours you estimated, the number of hours you worked on the unit, and the amount of time that passed between start and completion of this unit. Journal: Document your progress in your Course Journal. Some tasks may ask you to include specific items in your journal. Don’t overlook these. Insights: If you find something particularly noteworthy about this unit, make a note in your insights! page. 9.1.5 Prerequisites RPR-Objects-Data_frames (R “data frames”“) 9.2 Lists 9.3 Task 18 Load the R-Exercise_BasicSetup project in RStudio if you don’t already have it open. Type init() as instructed after the project has loaded. Continue below. The elements of matrices and arrays all have to be of the same type. Data frames allow us to store elements of different types in columns, but all columns have to have the same length and the elements have to be “atomic” - i.e. you can’t put vectors into dataframe columns. But R’s lists are much more versatile. They are simply ordered collections of components. These components can have different type - all kinds of R objects can go into a list: characters, booleans, any kind of numeric data, even functions - AND they can have different size. Lists are created with the list() function, which works similar to the c() function for vectors. Components are accessed through their index in double square brackets, or through their name, using the “$” operator, if the name has been defined. Here is an example: pUC19 &lt;- list(size=2686, marker=&quot;ampicillin&quot;, ori=&quot;ColE1&quot;, accession=&quot;L01397&quot;, BanI=c(235, 408, 550, 1647) ) objectInfo(pUC19) ## object contents:$size ## [1] 2686 ## ## $marker ## [1] &quot;ampicillin&quot; ## ## $ori ## [1] &quot;ColE1&quot; ## ## $accession ## [1] &quot;L01397&quot; ## ## $BanI ## [1] 235 408 550 1647 ## ## ## structure of object: ## List of 5 ## $ size : num 2686 ## $ marker : chr &quot;ampicillin&quot; ## $ ori : chr &quot;ColE1&quot; ## $ accession: chr &quot;L01397&quot; ## $ BanI : num [1:4] 235 408 550 1647 ## ## attributes: ## $names ## [1] &quot;size&quot; &quot;marker&quot; &quot;ori&quot; &quot;accession&quot; &quot;BanI&quot; pUC19[[1]] ## [1] 2686 pUC19[[2]] ## [1] &quot;ampicillin&quot; pUC19$ori ## [1] &quot;ColE1&quot; pUC19$BanI[2] ## [1] 408 Note that if we stored multiple restriction enzymes in one string, separated by commas, in our data frame example. While we can take such strings apart again, by using the strsplit() function, the string itself still has to be one single element in the data frame’s column. Lists have no such restriction. In our example above, we assigned a vector of restriction site positions to the element “BanI”. You can easily imagine that we could now create a list of lists, and that list of lists could hold an entire plasmid database in a most versatile way. Let’s do this! 9.4 Task 19 Create a list like with data for pACYC184 following the structure for the pUC19 example but using only size, marker and ori data: size: 4245 marker: Tet, Cam ori: p15A Confirm that your new list’s structure looks the pUC19 one (minus “accession”, and the “BanI”” element). Make a new list, call it plasmidDB and assign to it the puc19 list: plasmidDB &lt;- list() plasmidDB[[“pUC19”]] &lt;- pUC19 Add your pACYC184 list Add a third element to plasmidDB, “pBR322” using the pBR322 data: size: 4361 marker: Amp, Tet ori: ColE1 Then: retrieve the entire pACYC184 list Retrieve all sizes from the list. Use unlist() to flatten the result. Then use min() to find the size of the smallest one. 1 Lost? Solutions here (but don’t peek).↩︎ Whereas data frames allow you to get all data from a column directly, this is not possible for lists. You need a function that iterates over all list elements instead. Such a function is lapply(), one of several “apply” functions. For example, to get all “ori” elements, try: plasmidDB &lt;- list() plasmidDB[[&quot;pUC19&quot;]] &lt;- pUC19 lapply(plasmidDB, function(x) { return(x$ori) }) ## $pUC19 ## [1] &quot;ColE1&quot; 9.5 Self-evaluation Question 1: Execute: x &lt;- strsplit(plasmidData$Sites, “,”) and analyze the result. What is plasmidData$Sites? What is x? Why does strsplit() have a list as return value, not a vector or a data frame? 9.6 Further reading, links and resources If in doubt, ask! If anything about this learning unit is not clear to you, do not proceed blindly but ask for clarification. Post your question on the course mailing list: others are likely to have similar problems. Or send an email to your instructor. Author: Boris Steipe boris.steipe@utoronto.ca Created: 2017-08-05 Modified: 2018-05-05 Version: 1.0.2 Version history: 1.0.2 Maintenace 1.0.1 Fixed error in list example 1.0 Completed to first live version 0.1 Material collected from previous tutorial 9.6.1 Updated Revision history Revision Author Date Message 5152496 Ruth Isserlin 2019-12-25 Fixed issue with task numbering because of a remove all elements call in the 2nd chapter fab47ae Ruth Isserlin 2019-12-24 initial check in of R basics book 9.6.2 Footnotes: "],["r-subsetting.html", "Chapter 10 Subsetting and filtering R objects 10.1 Overview 10.2 Subsetting 10.3 Task 20 10.4 Task 21 10.5 Self-evaluation 10.6 Further reading, links and resources", " Chapter 10 Subsetting and filtering R objects (Subsetting with the [], [[]], and $ operators, filtering) 10.1 Overview 10.1.1 Abstract: Subsetting and filtering are among the most important operations with data. R provides powerful syntax for these operations. Learn about and practice them in this unit. 10.1.2 Objectives: This unit will: introduce subsetting principles; practice them on data; 10.1.3 Outcomes: After working through this unit you: can subset and filter data according to six different principles. 10.1.4 Deliverables: Time management: Before you begin, estimate how long it will take you to complete this unit. Then, record in your course journal: the number of hours you estimated, the number of hours you worked on the unit, and the amount of time that passed between start and completion of this unit. Journal: Document your progress in your Course Journal. Some tasks may ask you to include specific items in your journal. Don’t overlook these. Insights: If you find something particularly noteworthy about this unit, make a note in your insights! page. 10.1.5 Prerequisites RPR-Objects-Lists (R “Lists”) 10.2 Subsetting 10.3 Task 20 Load the R-Exercise_BasicSetup project in RStudio if you don’t already have it open. Type init() as instructed after the project has loaded. Continue below. We have encountered “subsetting” before, but we really need to discuss this in more detail. It is one of the most important topics of R since it is indispensable to select, transform, and otherwise modify data to prepare it for analysis. You have seen that we use square brackets to indicate individual elements in vectors and matrices. These square brackets are actually “operators”, and you can find more information about them in the help pages: ?&quot;[&quot; # Note that you need quotation marks around the operator for this. Note especially: “extracts” one or more elements defined within the brackets; [[ ]] “extracts” a single element defined within the brackets; $ “extracts” a single named element. “Elements” are not necessarily scalars, but can apply to a row, column, or more complex data structure. But a “single element” can’t be a range, or collection. Here are some examples of subsetting data from the plasmidData data frame we constructed previously. For the most part, this is review: plasmidData[1, ] ## Name Size Marker Ori Sites ## 1 pUC19 2686 Amp ColE1 EcoRI, SacI, SmaI, BamHI, XbaI, PstI, HindIII plasmidData[2, ] ## Name Size Marker Ori Sites ## 2 pBR322 4361 Amp, Tet ColE1 EcoRI, ClaI, HindIII we can extract more than one row by specifying the rows we want in a vector … plasmidData[c(1, 2), ] ## Name Size Marker Ori Sites ## 1 pUC19 2686 Amp ColE1 EcoRI, SacI, SmaI, BamHI, XbaI, PstI, HindIII ## 2 pBR322 4361 Amp, Tet ColE1 EcoRI, ClaI, HindIII … this works in any order … plasmidData[c(3, 1), ] ## Name Size Marker Ori Sites ## 3 pACYC184 4245 Tet, Cam p15A ClaI, HindIII ## 1 pUC19 2686 Amp ColE1 EcoRI, SacI, SmaI, BamHI, XbaI, PstI, HindIII … and for any number of rows … plasmidData[c(1, 2, 1, 2, 1, 2), ] ## Name Size Marker Ori Sites ## 1 pUC19 2686 Amp ColE1 EcoRI, SacI, SmaI, BamHI, XbaI, PstI, HindIII ## 2 pBR322 4361 Amp, Tet ColE1 EcoRI, ClaI, HindIII ## 1.1 pUC19 2686 Amp ColE1 EcoRI, SacI, SmaI, BamHI, XbaI, PstI, HindIII ## 2.1 pBR322 4361 Amp, Tet ColE1 EcoRI, ClaI, HindIII ## 1.2 pUC19 2686 Amp ColE1 EcoRI, SacI, SmaI, BamHI, XbaI, PstI, HindIII ## 2.2 pBR322 4361 Amp, Tet ColE1 EcoRI, ClaI, HindIII Same for columns plasmidData[ , 2 ] ## [1] 2686 4361 4245 We can select rows and columns by name if a name has been defined… plasmidData[, &quot;Name&quot;] ## [1] &quot;pUC19&quot; &quot;pBR322&quot; &quot;pACYC184&quot; plasmidData$Name # different syntax, same thing. This is the syntax I use most frequently. ## [1] &quot;pUC19&quot; &quot;pBR322&quot; &quot;pACYC184&quot; Watch this! plasmidData$Name[plasmidData$Ori != &quot;ColE1&quot;] ## [1] &quot;pACYC184&quot; What happened here? plasmidData$Ori != “ColE1” is a logical expression, it gives a vector of TRUE/FALSE values plasmidData$Ori != &quot;ColE1&quot; ## [1] FALSE FALSE TRUE We insert this vector into the square brackets. R then returns all rows for which the vector is TRUE. In this way we can “filter” for values plasmidData$Size &gt; 3000 ## [1] FALSE TRUE TRUE plasmidData$Name[plasmidData$Size &gt; 3000] ## [1] &quot;pBR322&quot; &quot;pACYC184&quot; This principle is what we use when we want to “sort” an object by some value. The function order() is used to return values that are sorted. Remember this: not sort() but order(). order(plasmidData$Size) ## [1] 1 3 2 plasmidData[order(plasmidData$Size), ] ## Name Size Marker Ori Sites ## 1 pUC19 2686 Amp ColE1 EcoRI, SacI, SmaI, BamHI, XbaI, PstI, HindIII ## 3 pACYC184 4245 Tet, Cam p15A ClaI, HindIII ## 2 pBR322 4361 Amp, Tet ColE1 EcoRI, ClaI, HindIII grep() matches substrings in strings and returns a vector of indices grep(&quot;Tet&quot;, plasmidData$Marker) ## [1] 2 3 plasmidData[grep(&quot;Tet&quot;, plasmidData$Marker), ] ## Name Size Marker Ori Sites ## 2 pBR322 4361 Amp, Tet ColE1 EcoRI, ClaI, HindIII ## 3 pACYC184 4245 Tet, Cam p15A ClaI, HindIII plasmidData[grep(&quot;Tet&quot;, plasmidData$Marker), &quot;Ori&quot;] ## [1] &quot;ColE1&quot; &quot;p15A&quot; Elements that can be extracted from an object also can be replaced. Simply assign the new value to the element. ( x &lt;- sample(1:10) ) ## [1] 6 3 1 5 8 7 4 2 9 10 x[4] &lt;- 99 x ## [1] 6 3 1 99 8 7 4 2 9 10 ( x &lt;- x[order(x)] ) ## [1] 1 2 3 4 6 7 8 9 10 99 Try your own subsetting ideas. Play with this. I find that even seasoned investigators have problems with subsetting their data and if you become comfortable with the many ways of subsetting, you will be ahead of the game right away. 10.4 Task 21 The R-Exercise_BasicSetup project contains a file subsettingPractice.R Open the file and work through it. 10.5 Self-evaluation 10.6 Further reading, links and resources If in doubt, ask! If anything about this learning unit is not clear to you, do not proceed blindly but ask for clarification. Post your question on the course mailing list: others are likely to have similar problems. Or send an email to your instructor. Author: Boris Steipe boris.steipe@utoronto.ca Created: 2017-08-05 Modified: 2018-05-05 Version: 1.0.1 Version history: 1.0.1 Maintenace 1.0 Completed to first live version 0.1 Material collected from previous tutorial 10.6.1 Updated Revision history Revision Author Date Message 5152496 Ruth Isserlin 2019-12-25 Fixed issue with task numbering because of a remove all elements call in the 2nd chapter fab47ae Ruth Isserlin 2019-12-24 initial check in of R basics book 10.6.2 Footnotes: "],["r-control-structures.html", "Chapter 11 Control structures of R 11.1 Overview 11.2 Control structures 11.3 Task 22 11.4 Task 23 11.5 Self-evaluation 11.6 Further reading, links and resources", " Chapter 11 Control structures of R (if, else if, ifelse, for, and while; vectorized commands as alternatives) 11.1 Overview 11.1.1 Abstract: Introducing control structures: if, else if, ifelse, for, and while. 11.1.2 Objectives: This unit will: introduce the main control structures of R; 11.1.3 Outcomes: After working through this unit you: can read, analyze and write conditional expressions using if, else, and the ifelse() function; can read, analyze and write for loops using the range operator and the seq_along() function; can construct while loops with a termination condition. 11.1.4 Deliverables: Time management: Before you begin, estimate how long it will take you to complete this unit. Then, record in your course journal: the number of hours you estimated, the number of hours you worked on the unit, and the amount of time that passed between start and completion of this unit. Journal: Document your progress in your Course Journal. Some tasks may ask you to include specific items in your journal. Don’t overlook these. Insights: If you find something particularly noteworthy about this unit, make a note in your insights! page. 11.1.5 Prerequisites RPR-Subsetting (Subsetting and filtering R objects) 11.2 Control structures “Control structures” are parts of the syntax that execute code according to whether some condition is met. Let’s look at this with some simple examples: 11.2.1 if and else # Code pattern if (&lt;conditional expression evaluates to TRUE&gt;) { &lt;execute this block&gt; } else if (&lt;expression evaluates to TRUE&gt;) { &lt;execute this block&gt; } else { &lt;execute this block&gt; } 11.2.2 conditional expressions anything that evaluates to TRUE or FALSE, or can be coerced to a logical. Obviously the operators: ! - not equals == - equals &lt; - less than \\&gt; - greater than &lt;= - less than or equal \\&gt;= - greater than or equal but there are also a number of in-built functions that are useful for this purpose: * all - are all values in the set TRUE * any - are any of the values in the set TRUE * exists - does the object exist * is.character - is the object of type character * is.factor - is the object of type factor * is.integer - is the object of type integer * is.null - is the object null * is.na - is the object NA * is.nan - is the object infinite. * is.numeric - is the object of type numeric * is.unsorted - is the object sorted * is.vector - is the object of type vector Simple “if” statement: Rolling a die. If you get a “six”, you get to roll again. x &lt;- sample(1:6, 1) if (x == 6) { x &lt;- c(x, sample(1:6, 1)) } print(x) ## [1] 5 11.2.3 “if”, “else if”, and “else” Here is a popular dice game called high-low. a &lt;- sample(1:6, 1) b &lt;- sample(1:6, 1) if (a + b &gt; 7) { print(&quot;high&quot;) } else if (a + b &lt; 7) { print(&quot;low&quot;) } else { print(&quot;seven&quot;) } ## [1] &quot;high&quot; We need to talk about conditional expressions that test for more than one condition for a moment, things like: “if this is true OR that is true OR my birthday is a Sunday this year …”. To join logical expressions, R has two distinct sets of operators: and ||, and &amp; and &amp;&amp;. | is for “or” and &amp; is for “and”. But what about &amp;&amp; and ||? The single operators are “vectorized” whereas the doubled operators short-circuit. This means if you apply the single operators to a vector, you get a vector of results: x &lt;- c(1, 3, 5, 7, 11, 13, 17) x &gt; 3 &amp; x &lt; 17 # FALSE FALSE TRUE TRUE TRUE TRUE FALSE: all comparisons ## [1] FALSE FALSE TRUE TRUE TRUE TRUE FALSE x [x &gt; 3 &amp; x &lt; 17] # 5 7 11 13 ## [1] 5 7 11 13 whereas this stop at the first FALSE tryCatch({x &gt; 3 &amp;&amp; x &lt; 17 ; print(&quot;FALSE&quot;)}, error = function(e){print(e)}) ## &lt;simpleError in x &gt; 3 &amp;&amp; x &lt; 17: &#39;length = 7&#39; in coercion to &#39;logical(1)&#39;&gt; The vectorized version is usually what you want, e.g. for subsetting, as above. But it is usually not the right way in control structures: there, you usually want never to evaluate unnecessary expressions. Chained “OR” expressions can be aborted after the first TRUE is encountered, and chained “AND” expressions can be aborted after the first FALSE. Which is what the double operators do. no error: length test is TRUE so is.na() never gets evaluated x &lt;- numeric() if (length(x) == 0 || is.na(x)) { print(&quot;zero&quot;) } # . ## [1] &quot;zero&quot; whereas this throws an error, because is.na() is evaluated even though x has length zero. if (length(x) == 0 | is.na(x)) { print(&quot;zero&quot;) } Bottom line: always use || and &amp;&amp; in control structures. 11.2.4 ifelse The ifelse() function deserves special mention: its arguments work like an if / else construct … ifelse(5 &gt; 7, TRUE, FALSE) ifelse(runif(1) &gt; 0.5, &quot;pickles&quot;, &quot;cucumbers&quot;) ## [1] &quot;pickles&quot; i.e. ifelse(, , ) But the cool thing about ifelse() is that it’s vectorized! You can apply it to a whole vector of conditions at once: set.seed(27); runif(10) ## [1] 0.971750231 0.083757509 0.873869923 0.329231364 0.222275513 0.401648218 ## [7] 0.072498519 0.002450234 0.137093998 0.191909064 set.seed(27); runif(10) &gt; 0.2 ## [1] TRUE FALSE TRUE TRUE TRUE TRUE FALSE FALSE FALSE FALSE set.seed(27); ifelse(runif(10) &gt; 0.2, &quot;caution&quot;, &quot; to the wind&quot;) ## [1] &quot;caution&quot; &quot; to the wind&quot; &quot;caution&quot; &quot;caution&quot; &quot;caution&quot; ## [6] &quot;caution&quot; &quot; to the wind&quot; &quot; to the wind&quot; &quot; to the wind&quot; &quot; to the wind&quot; set.seed(NULL) 11.2.5 for “for” loops are the workhorse of innumerable R scripts. They are controlled by a sequence, and a variable. The body of the loop is executed once for each element in the sequence. Most often, the sequence is a sequence of integers, created with the colon - the range operator. The pattern is: for ( in ) { &lt;expressions using element…&gt; } # simple for loop for (i in 1:10) { print(c(i, i^2, i^3)) } ## [1] 1 1 1 ## [1] 2 4 8 ## [1] 3 9 27 ## [1] 4 16 64 ## [1] 5 25 125 ## [1] 6 36 216 ## [1] 7 49 343 ## [1] 8 64 512 ## [1] 9 81 729 ## [1] 10 100 1000 Let’s stay with the high-low game for a moment: What are the odds of winning? Let’s simulate some runs with a “for” loop. N &lt;- 25000 outcomes &lt;- character(N) # initialize an empty vector for (i in 1:N) { # repeat, assign each element of 1:N to # the variable &quot;i&quot; in turn a &lt;- sample(1:6, 1) b &lt;- sample(1:6, 1) if (a + b &gt; 7) { outcomes[i] &lt;- &quot;high&quot; } else if (a + b &lt; 7) { outcomes[i] &lt;- &quot;low&quot; } else { outcomes[i] &lt;- &quot;seven&quot; } } head(outcomes, 36) ## [1] &quot;high&quot; &quot;high&quot; &quot;low&quot; &quot;high&quot; &quot;low&quot; &quot;low&quot; &quot;high&quot; &quot;seven&quot; &quot;seven&quot; ## [10] &quot;high&quot; &quot;high&quot; &quot;low&quot; &quot;seven&quot; &quot;low&quot; &quot;low&quot; &quot;low&quot; &quot;high&quot; &quot;low&quot; ## [19] &quot;high&quot; &quot;high&quot; &quot;high&quot; &quot;high&quot; &quot;high&quot; &quot;seven&quot; &quot;high&quot; &quot;high&quot; &quot;low&quot; ## [28] &quot;high&quot; &quot;high&quot; &quot;high&quot; &quot;seven&quot; &quot;low&quot; &quot;low&quot; &quot;low&quot; &quot;low&quot; &quot;high&quot; table(outcomes) # the table() function tabulates the elements ## outcomes ## high low seven ## 10376 10492 4132 # of a vector round((36 * table(outcomes))/N) # Can you explain this expression? Note that there is nothing special about the expression for (i in 1:N) { … . Any expression that generates a sequence of items will do; I write a lot of code like for (fileName in dir()) { … or for (gene in data$name) {… , or for (column in colnames(expressionTable)) {… etc. Loops in R can be slow if you are not careful how you write them. The reason is usually related to dynamically managing memory. If you can, you should always pre-define objects of sufficient size to hold your results. Even better, use a vectorized approach. 11.2.6 Compare excution times: one million square roots from a vector of random numbers … Version 1: Naive for-loop: grow result object as required N &lt;- 1000000 # Set N to a large number x &lt;- runif(N) # get N uniformily distributed random numbers y &lt;- numeric() # create a variable to assign to startTime &lt;- Sys.time() # save start time for (i in 1:N) { # loop N-times y[i] &lt;- sqrt(x[i]) # calculate one square root, grow y to store it } Sys.time() - startTime # time it took ## Time difference of 0.643281 secs rm(x) # clean up rm(y) Version 2: Define result object to be large enough N &lt;- 1000000 # Set N to a large number x &lt;- runif(N) # get N uniformily distributed random numbers y &lt;- numeric(N) # create a variable with N slots startTime &lt;- Sys.time() # save start time for (i in 1:N) { # loop N-times y[i] &lt;- sqrt(x[i]) # calculate one square root, store in Y } Sys.time() - startTime # time it took ## Time difference of 0.07021832 secs rm(x) # clean up rm(y) Version 3: vectorized N &lt;- 1000000 # Set N to a large number x &lt;- runif(N) # get N uniformily distributed random numbers startTime &lt;- Sys.time() # save start time y &lt;- sqrt(x) # sqrt() is vectorized! Sys.time() - startTime # time it took ## Time difference of 0.00537467 secs rm(x) # clean up rm(y) The tiny change of pre-allocating memory for the result object y, rather than dynamically growing the vector has made a huge difference. But using the vectorized version of the sqrt() function directly is the fastest approach. 11.2.7 seq_along() vs. range Consider the following carefully: Assume we write a loop to iterate over vectors of variable length for example going from e to pi with a given number of elements: ( v5 &lt;- seq(exp(1), pi, length.out = 5) ) ## [1] 2.718282 2.824110 2.929937 3.035765 3.141593 ( v2 &lt;- seq(exp(1), pi, length.out = 2) ) ## [1] 2.718282 3.141593 ( v1 &lt;- seq(exp(1), pi, length.out = 1) ) ## [1] 2.718282 ( v0 &lt;- seq(exp(1), pi, length.out = 0) ) ## integer(0) The idiom we will probably find most commonly for this task is uses the range operator “:” 1:length(v5) ## [1] 1 2 3 4 5 1:length(v2) ## [1] 1 2 for (i in 1:length(v5)) { print(v5[i]) } ## [1] 2.718282 ## [1] 2.82411 ## [1] 2.929937 ## [1] 3.035765 ## [1] 3.141593 for (i in 1:length(v2)) { print(v2[i]) } ## [1] 2.718282 ## [1] 3.141593 for (i in 1:length(v1)) { print(v1[i]) } ## [1] 2.718282 for (i in 1:length(v0)) { print(v0[i]) } ## [1] NA ## integer(0) The problem with the last iteration is: we probably didn’t want to execute the loop if the vector has length 0. But since 1:length(v0) is the same as 1:0, we get an erroneous execution. This is why we should always use the following idiom instead, when iterating over a vector: the function seq_along(). seq_along() builds a vector of indices over its argument. seq_along(v5) ## [1] 1 2 3 4 5 seq_along(v2) ## [1] 1 2 seq_along(v1) ## [1] 1 seq_along(v0) ## integer(0) for (i in seq_along(v5)) { print(v5[i]) } ## [1] 2.718282 ## [1] 2.82411 ## [1] 2.929937 ## [1] 3.035765 ## [1] 3.141593 for (i in seq_along(v2)) { print(v2[i]) } ## [1] 2.718282 ## [1] 3.141593 for (i in seq_along(v1)) { print(v1[i]) } ## [1] 2.718282 for (i in seq_along(v0)) { print(v0[i]) } Now we get the expected behaviour: no output if the vector is empty. 11.2.8 loops vs. vectorized expressions If you can achieve your result with an R vector expression, it will be faster than using a loop. But sometimes you need to do things explicitly, for example if you need to access intermediate results. Here is an example to play some more with loops: a password generator. Passwords are a pain. We need them everywhere, they are frustrating to type, to remember and since the cracking programs are getting smarter they become more and more likely to be broken. Here is a simple password generator that creates random strings with consonant/vowel alterations. These are melodic and easy to memorize, but actually as strong as an 8-character, fully random password that uses all characters of the keyboard such as “!He.%2jJ” or “#hb,B2X^” (which is pretty much unmemorizable). The former is taken from 20^7 X 7^7 10^15 possibilities, the latter is from 94^8 ~ 6 X 10^15 possibilities. High-end GPU supported password crackers can test about 109 passwords a second, the passwords generated by this little algorithm would thus take on the order of 10^6 seconds or eleven days to crack16. This is probably good enough to deter a casual attack. 11.3 Task 22 Copy, study and run the below code # Suggest memorizable passwords # Below we use the functions: ?nchar ?sample ?substr ?paste ?print #define a string of consonants ... con &lt;- &quot;bcdfghjklmnpqrstvwxz&quot; # ... and a string of of vowels vow &lt;- &quot;aeiouy&quot; for (i in 1:10) { # ten sample passwords to choose from ... pass = rep(&quot;&quot;, 14) # make an empty character vector for (j in 1:7) { # seven consonant/vowel pairs to be created ... k &lt;- sample(1:nchar(con), 1) # pick a random index for consonants ... ch &lt;- substr(con,k,k) # ... get the corresponding character ... idx &lt;- (2*j)-1 # ... compute the position (index) of where to put the consonant ... pass[idx] &lt;- ch # ... and put it in the right spot # same thing for the vowel, but coded with fewer intermediate assignments # of results to variables k &lt;- sample(1:nchar(vow), 1) pass[(2*j)] &lt;- substr(vow,k,k) } print( paste(pass, collapse=&quot;&quot;) ) # collapse the vector in to a string and print } Try this a few times. 11.3.1 while Whereas a for-loop runs for a fixed number of times, a “while” loop runs as long as a condition is true, possibly forever. Here is an example, again our high-low game: this time we simulate what happens when we play it more than once with a strategy that compensates us for losing. Let’s assume we are playing high-low in a casino. You can bet high or low. You get two dollars for one if you win, nothing if you lose. If you bet “high”, you lose if we roll “low” or “seven”. Thus your chances of winning are 15/36 = 42%. You play the following strategy: start with 33 dollars. Bet one dollar. If you win, good. If you loose, triple your bet. Stop the game when your funds are gone (bad), or if you have more than 100 dollars (good) - i.e. you have tripled the funds you risked. Also stop if you’ve played more than 100 rounds and start getting bored. funds &lt;- 33 bet &lt;- 1 # our first bet nPlays &lt;- 0 # this counts how often we&#39;ve played MAXPLAYS &lt;- 100 set.seed(1234567) while (funds &gt; 0 &amp;&amp; funds &lt; 100 &amp;&amp; nPlays &lt; MAXPLAYS) { bet &lt;- min(bet, funds) # can&#39;t bet more than we have. funds &lt;- funds - bet # place the bet a &lt;- sample(1:6, 1) # roll the dice b &lt;- sample(1:6, 1) # we always play &quot;high&quot; if (a + b &gt; 7) { # we win :-) result &lt;- &quot;Win! &quot; funds &lt;- funds + (2 * bet) bet &lt;- 1 # reset the bet to one dollar } else { # we lose :-( result &lt;- &quot;Lose.&quot; bet &lt;- 3 * bet # increase the bet to 3 times previous } print(paste(&quot;Round&quot;, nPlays, result, &quot;Funds now:&quot;, funds, &quot;Next bet:&quot;, bet)) nPlays &lt;- nPlays + 1 } ## [1] &quot;Round 0 Lose. Funds now: 32 Next bet: 3&quot; ## [1] &quot;Round 1 Win! Funds now: 35 Next bet: 1&quot; ## [1] &quot;Round 2 Win! Funds now: 36 Next bet: 1&quot; ## [1] &quot;Round 3 Lose. Funds now: 35 Next bet: 3&quot; ## [1] &quot;Round 4 Lose. Funds now: 32 Next bet: 9&quot; ## [1] &quot;Round 5 Lose. Funds now: 23 Next bet: 27&quot; ## [1] &quot;Round 6 Lose. Funds now: 0 Next bet: 69&quot; set.seed(NULL) Now before you get carried away - try this with different seeds and you’ll quickly figure out that the odds of beating the game are not all that great… 11.4 Task 23 A rocket ship has to sequence a countdown for the rocket to launch. You are starting the countdown from 3. You want to print the value of variable named txt that outputs: [1] “3” “2” “1” “0” “Lift Off!” Using what you learned above, write a while loop that gives the output above. Sample Solution: start &lt;- 3 txt &lt;- as.character(start) countdown &lt;- start while (countdown &gt; 0) { countdown &lt;- countdown - 1 txt &lt;- c(txt, countdown) } txt &lt;- c(txt, “Lift Off!”) txt 11.5 Self-evaluation 11.6 Further reading, links and resources If in doubt, ask! If anything about this learning unit is not clear to you, do not proceed blindly but ask for clarification. Post your question on the course mailing list: others are likely to have similar problems. Or send an email to your instructor. Author: Boris Steipe boris.steipe@utoronto.ca Created: 2017-08-05 Modified: 2019-01-07 Version: 1.1 Version history: 1.0 Udate set.seed() usage 1.0.1 Maintenance; clarify for-loop comparison 1.0 Completed to first live version 0.1 Material collected from previous tutorial 11.6.1 Updated Revision history Revision Author Date Message 5152496 Ruth Isserlin 2019-12-25 Fixed issue with task numbering because of a remove all elements call in the 2nd chapter fab47ae Ruth Isserlin 2019-12-24 initial check in of R basics book 11.6.2 Footnotes: That’s assuming the worst case in that the attacker needs to know the pattern with which the password is formed, i.e. the number of characters and the alphabet that we chose from. But note that there is an even worse case: if the attacker had access to our code and the seed to our random number generator. If you start the random number generator e.g. with a new seed that is generated from Sys.time(), the possible space of seeds can be devastatingly small. But even if a seed is set explicitly with the set.seed() function, the seed is a 32-bit integer (check this with .Machine$integer.max) and thus can take only a bit more than 4 X 10^9 values, six orders of magnitude less than the 10^15 password complexity we thought we had! It turns out that the code may be a much greater vulnerability than the password itself. Keep that in mind. Keep it secret. Keep it safe.↩︎ "],["r-functions.html", "Chapter 12 R Functions 12.1 Overview 12.2 Functions", " Chapter 12 R Functions (Anatomy of a function: arguments, parameters and values; the concept of functional programming.) 12.1 Overview 12.1.1 Abstract: In this unit we discuss the “anatomy”” of R functions: arguments, parameters and values, and how R’s treatment of functions supports “functional programming”. 12.1.2 Objectives: This unit will: introduce the basic pattern of R functions; discuss arguments and parameters; show how to retrieve the source code from within a function; practice writing your own functions. 12.1.3 Outcomes: After working through this unit you: know how to pass parameters into functions and assign the returned values; can read, analyze, and write your own functions. 12.1.4 Deliverables: Time management: Before you begin, estimate how long it will take you to complete this unit. Then, record in your course journal: the number of hours you estimated, the number of hours you worked on the unit, and the amount of time that passed between start and completion of this unit. Journal: Document your progress in your Course Journal. Some tasks may ask you to include specific items in your journal. Don’t overlook these. Insights: If you find something particularly noteworthy about this unit, make a note in your insights! page. 12.1.5 Prerequisites RPR-Control_structures (Control structures of R) 12.2 Functions R is considered an (impure) functional programming language and thus the focus of R programs is on functions. The key advantage is that this encourages programming without side-effects and this makes it easier to write error free code and maintain it. Function parameters17 are instantiated for use inside a function as the function’s arguments, and a single result is returned[However a function may have side-effects, such as writing something to console, plotting graphics, saving data to a file, or changing the value of variables outside the function scope. But changing values outside the scope is poor practice, always to be avoided.]. The return values can either be assigned to a variable, or used directly as the argument of another function. This means functions can be nested, and intermediate assignment is not required. Functions are either built-in (i.e. available in the basic R installation), loaded via specific packages, or they can be easily defined by you (see below). In general a function is invoked through its name, followed by one or more arguments in parentheses, separated by commas. Whenever I refer to a function, I write the parentheses to identify it as such and not a constant or other keyword eg. log(). Here are some examples for you to try and play with: cos(pi) #&quot;pi&quot; is a predefined constant. ## [1] -1 Note the rounding error. This number is not really different from zero. sin(pi) ## [1] 1.224647e-16 Trigonometric functions use radians as their argument - this conversion calculates sin(30 degrees). sin(30 * pi/180) ## [1] 0.5 “e” is not predefined, but easy to calculate. exp(1) ## [1] 2.718282 functions can be arguments to functions - nested functions are evaluated from the inside out. log(exp(1)) # ## [1] 1 log() calculates natural logarithms; convert to any base by dividing by the log of the base. Here: log to base 10. log(10000) / log(10) ## [1] 4 Euler’s identity exp(complex(r=0, i=pi)) ## [1] -1+1.224647e-16i There are several ways to populate the argument list for a function and R makes a reasonable guess what you want to do. Arguments can either be used in their predefined order, or assigned via an argument name. Let’s look at the complex() function to illustrate this. Consider the specification of a complex number in Euler’s identity above. The function complex() can work with a number of arguments that are explained in the documentation (see: ?complex). Its signature includes length.out, real, imaginary, and some more. complex(length.out = 0, real = numeric(), imaginary = numeric(), modulus = 1, argument = 0) ## [1] 1+0i The length.out argument creates a vector with one or more complex numbers. If nothing else is specified, this will be a vector of complex zero(s). If there are two, or three arguments, they will be placed in the respective slots. However, since the arguments are named, we can also define which slot of the argument list they should populate. Consider the following to illustrate this: complex(1) ## [1] 0+0i parameter is in the first slot -&gt; length.out complex(4) ## [1] 0+0i 0+0i 0+0i 0+0i imaginary part missing complex(1, 2) ## [1] 2+0i one complex number with real and imaginary parts defined complex(1, 2, 3) ## [1] 2+3i four complex numbers complex(4, 2, 3) ## [1] 2+3i 2+3i 2+3i 2+3i defining values via named parameters complex(real = 0, imaginary = pi) ## [1] 0+3.141593i same thing - if names are used, order is not important complex(imaginary = pi, real = 0) ## [1] 0+3.141593i names can be abbreviated … complex(re = 0, im = pi) ## [1] 0+3.141593i … to the shortest string that is unique among the named parameters, but this is poor practice, strongly advises against. complex(r = 0, i = pi) ## [1] 0+3.141593i Think: what have I done here? Why does this work? complex(i = pi, 1, 0) ## [1] 0+3.141593i The terms parameter and argument have similar but distinct meanings. A parameter is an item that appears in the function definition, an argument is the actual value that is passed into the function.↩︎ "],["the-complex-number-above-is-the-same-as-in-eulers-identity..html", "Chapter 13 (The complex number above is the same as in Euler’s identity.) 13.1 Task 24 13.2 On missing parameters 13.3 Reading functions 13.4 Primitives 13.5 Writing your own functions 13.6 Task 25 13.7 Task 26 13.8 Self-evaluation 13.9 Further reading, links and resources", " Chapter 13 (The complex number above is the same as in Euler’s identity.) exp(complex(i = pi, 1, 0)) ## [1] -1+1.224647e-16i 13.1 Task 24 A frequently used function is seq(). Read the help page about seq() Use seq() to generate a sequence of integers from -5 to 3. Pass arguments in default order, don’t use argument names. Use seq() to generate a sequence of numbers from -2 to 2 in intervals of 1/3. This time, use argument names. Use seq() to generate a sequence of 30 numbers between 1 and 100. Pass the arguments in the following order: length.out, to, from. 13.2 On missing parameters If a parameter is missing several things can happen. Let’s illustrate wih a little function that returns the golden-ratio pair to a number, either the smaller, or the larger one. goldenRatio &lt;- function(x, smaller) { phi &lt;- (1 + sqrt(5)) / 2 if (smaller == TRUE) { return(x / phi) } else { return(x * phi) } } If there’s no way to recover, executing the function will throw an error: goldenRatio(1) Error in goldenRatio(1) : argument “smaller” is missing, with no default If the function has a default parameter defined, it is used : goldenRatio &lt;- function(x, smaller = TRUE) { phi &lt;- (1 + sqrt(5)) / 2 if (smaller == TRUE) { return(x / phi) } else { return(x * phi) } } goldenRatio(1) ## [1] 0.618034 Alternatively, the function body can check whether a parameter is missing with the missing() function, and then react accordingly: goldenRatio &lt;- function(x, smaller) { if (missing(smaller)) { smaller &lt;- TRUE } phi &lt;- (1 + sqrt(5)) / 2 if (smaller == TRUE) { return(x / phi) } else { return(x * phi) } } goldenRatio(1) ## [1] 0.618034 goldenRatio(1, smaller = FALSE) ## [1] 1.618034 Why is this useful, if you could just define a default? Because the parameter can then be the result of a (complex) computation, based on other parameters. 13.3 Reading functions 13.3.1 Basic R If the function is a normal R function, like the ones we have defined above, you can read the function code when type its name without parantheses: goldenRatio ## function (x, smaller) ## { ## if (missing(smaller)) { ## smaller &lt;- TRUE ## } ## phi &lt;- (1 + sqrt(5))/2 ## if (smaller == TRUE) { ## return(x/phi) ## } ## else { ## return(x * phi) ## } ## } ## &lt;bytecode: 0x55ab672301c8&gt; But that strictly only works for functions which have been written in basic R code. 13.3.2 S3 methods You might also get a line saying UseMethod(). Then you are looking at a “method” from R’s S3 object oriented system - such a function is also called a “generic”, because it dispatches to more specific code, depending on the type of the parameter it is being given. Use methods() to see which specific methods are defined, and then use getAnywhere(&lt;function.class&gt;) to get the code. seq ## function (...) ## UseMethod(&quot;seq&quot;) ## &lt;bytecode: 0x55ab676df0d8&gt; ## &lt;environment: namespace:base&gt; methods(seq) ## [1] seq.Date seq.default seq.POSIXt ## see &#39;?methods&#39; for accessing help and source code getAnywhere(seq.default) ## A single object matching &#39;seq.default&#39; was found ## It was found in the following places ## package:base ## registered S3 method for seq from namespace base ## namespace:base ## with value ## ## function (from = 1, to = 1, by = ((to - from)/(length.out - 1)), ## length.out = NULL, along.with = NULL, ...) ## { ## is.logint &lt;- function(.) (is.integer(.) || is.logical(.)) &amp;&amp; ## !is.object(.) ## if ((One &lt;- nargs() == 1L) &amp;&amp; !missing(from)) { ## lf &lt;- length(from) ## return(if (mode(from) == &quot;numeric&quot; &amp;&amp; lf == 1L) { ## if (!is.finite(from)) stop(&quot;&#39;from&#39; must be a finite number&quot;) ## 1L:from ## } else if (lf) 1L:lf else integer()) ## } ## if (!missing(along.with)) { ## length.out &lt;- length(along.with) ## if (One) ## return(if (length.out) seq_len(length.out) else integer()) ## intn1 &lt;- is.integer(length.out) ## } ## else if (!missing(length.out)) { ## len &lt;- length(length.out) ## if (!len) ## stop(&quot;argument &#39;length.out&#39; must be of length 1&quot;) ## if (len &gt; 1L) { ## warning(&quot;first element used of &#39;length.out&#39; argument&quot;) ## length.out &lt;- length.out[1L] ## } ## if (!(intn1 &lt;- is.logint(length.out))) ## length.out &lt;- as.numeric(ceiling(length.out)) ## } ## chkDots(...) ## if (!missing(from) &amp;&amp; length(from) != 1L) ## stop(&quot;&#39;from&#39; must be of length 1&quot;) ## if (!missing(to) &amp;&amp; length(to) != 1L) ## stop(&quot;&#39;to&#39; must be of length 1&quot;) ## if (!missing(from) &amp;&amp; !is.finite(if (is.character(from)) from &lt;- as.numeric(from) else from)) ## stop(&quot;&#39;from&#39; must be a finite number&quot;) ## if (!missing(to) &amp;&amp; !is.finite(if (is.character(to)) to &lt;- as.numeric(to) else to)) ## stop(&quot;&#39;to&#39; must be a finite number&quot;) ## if (is.null(length.out)) ## if (missing(by)) ## from:to ## else { ## int &lt;- is.logint(from) &amp;&amp; is.logint(to) ## del &lt;- to - if (int) ## as.double(from) ## else from ## if (del == 0 &amp;&amp; to == 0) ## return(to) ## if (length(by) != 1L) ## stop(&quot;&#39;by&#39; must be of length 1&quot;) ## if (!is.logint(by)) ## int &lt;- FALSE ## else if (!int) ## storage.mode(by) &lt;- &quot;double&quot; ## n &lt;- if (finite.del &lt;- is.finite(del)) ## del/by ## else to/by - from/by ## if (!is.finite(n)) { ## if (!is.na(by) &amp;&amp; by == 0 &amp;&amp; del == 0) ## return(from) ## stop(&quot;invalid &#39;(to - from)/by&#39;&quot;) ## } ## if (n &lt; 0L) ## stop(&quot;wrong sign in &#39;by&#39; argument&quot;) ## if (n &gt; .Machine$integer.max) ## stop(&quot;&#39;by&#39; argument is much too small&quot;) ## if (finite.del &amp;&amp; abs(del)/max(abs(to), abs(from)) &lt; ## 100 * .Machine$double.eps) ## return(from) ## if (int) { ## n &lt;- as.integer(n) ## if (n &gt;= 2L) ## cumsum(rep.int(c(from, by), c(1L, n))) ## else from + (0L:n) * by ## } ## else { ## n &lt;- as.integer(n + 1e-10) ## x &lt;- if (finite.del) ## from + (0L:n) * by ## else (from/4 + (0L:n) * (by/4)) * 4 ## if (by &gt; 0) ## pmin(x, to) ## else pmax(x, to) ## } ## } ## else if (!is.finite(length.out) || length.out &lt; 0L) ## stop(&quot;&#39;length.out&#39; must be a non-negative number&quot;) ## else if (length.out == 0L) ## integer() ## else if (One) ## seq_len(length.out) ## else if (missing(by)) { ## if (missing(to)) { ## to &lt;- from + (length.out - 1) ## intdel &lt;- intn1 &amp;&amp; is.logint(from) &amp;&amp; to &lt;= .Machine$integer.max ## if (intdel) ## storage.mode(to) &lt;- &quot;integer&quot; ## } ## else intdel &lt;- is.logint(to) ## if (missing(from)) { ## from &lt;- to - (length.out - 1) ## if (intdel) { ## intdel &lt;- intn1 &amp;&amp; from &gt;= -.Machine$integer.max ## if (intdel) ## storage.mode(from) &lt;- &quot;integer&quot; ## } ## } ## else if (intdel) ## intdel &lt;- is.logint(from) ## if (length.out &gt; 2L) ## if (from == to) ## rep.int(from, length.out) ## else { ## n1 &lt;- length.out - 1L ## if (intdel &amp;&amp; intn1 &amp;&amp; from%%n1 == to%%n1) { ## by &lt;- to%/%n1 - from%/%n1 ## cumsum(rep.int(c(from, by), c(1L, n1))) ## } ## else { ## if (intdel) ## storage.mode(from) &lt;- &quot;double&quot; ## del &lt;- to - from ## if (is.finite(del)) { ## as.vector(c(from, from + seq_len(length.out - ## 2L) * (del/n1), to)) ## } ## else { ## from &lt;- from/4 ## to &lt;- to/4 ## as.vector(c(from, from + seq_len(length.out - ## 2L) * ((to - from)/n1), to)) * 4 ## } ## } ## } ## else as.vector(c(from, to))[seq_len(length.out)] ## } ## else if (missing(to)) { ## int &lt;- (intby &lt;- is.logint(by)) &amp;&amp; is.logint(from) &amp;&amp; ## (!(nby &lt;- length(by)) || (naby &lt;- is.na(by)) || ((to &lt;- from + ## (length.out - 1) * by) &lt;= .Machine$integer.max &amp;&amp; ## to &gt;= -.Machine$integer.max)) ## if (int &amp;&amp; length.out &gt; 2L &amp;&amp; nby == 1L &amp;&amp; !naby) ## cumsum(rep.int(c(from, by), c(1L, length.out - 1L))) ## else { ## if (intby &amp;&amp; !(int || is.object(from))) ## storage.mode(by) &lt;- &quot;double&quot; ## from + (0L:(length.out - 1L)) * by ## } ## } ## else if (missing(from)) { ## int &lt;- (intby &lt;- is.logint(by)) &amp;&amp; is.logint(to) &amp;&amp; (!(nby &lt;- length(by)) || ## (naby &lt;- is.na(by)) || ((from &lt;- to - (length.out - ## 1) * by) &gt;= -.Machine$integer.max &amp;&amp; from &lt;= .Machine$integer.max)) ## if (int &amp;&amp; length.out &gt; 2L &amp;&amp; nby == 1L &amp;&amp; !naby) ## cumsum(rep.int(c(as.integer(from), by), c(1L, length.out - ## 1L))) ## else { ## if (intby &amp;&amp; !(int || is.object(to))) ## storage.mode(by) &lt;- &quot;double&quot; ## to - ((length.out - 1L):0L) * by ## } ## } ## else stop(&quot;too many arguments&quot;) ## } ## &lt;bytecode: 0x55ab676de230&gt; ## &lt;environment: namespace:base&gt; 13.4 Primitives You might also get a line saying .Call(C_ ). Then you are looking at a primitive - a function that has been compiled in the C programming language, for efficiency. runif ## function (n, min = 0, max = 1) ## .Call(C_runif, n, min, max) ## &lt;bytecode: 0x55ab692f85d8&gt; ## &lt;environment: namespace:stats&gt; To read the C source code, just do a Google search for the function name in the repository where the R sources are kept: This search finds runif.c (have a look).site:https://svn.r-project.org/R/trunk/src runif 13.5 Writing your own functions R is a “functional programming language” and working with R will involve writing your own functions. This is easy and gives you access to flexible, powerful and reusable solutions. You have to understand the “anatomy” of an R function however. Functions are assigned to function names. They are treated like any other R object and you can have vectors of functions, and functions that return functions etc. Data gets into the function via the function’s parameters. Data is returned from a function via the return() statement[Actually the return() statement is optional, if missing, the result of the last expression is returned. You will find this frequently in other people’s code, somthing to be aware of. However, you’ll surely understand that it is really poor practice to omit return(), it makes the code harder to read and can give rise to misunderstandings. Never use implicit behaviour where you can be explicit instead]. One and only one object is returned. However the object can be a list, and thus contain values of arbitrary complexity. This is called the “value” of the function. Well-written functions have no side-effects like changing global variables. # the function definition pattern: &lt;myName&gt; &lt;- function(&lt;myArguments&gt;) { # &lt;documentation!&gt; result &lt;- &lt;do something with the parameters&gt; return(result) } In this pattern, the function is assigned to the name - any valid name in R. Once it is assigned, it the function can be invoked with myName(). The parameter list (the values we write into the parentheses following the function name) can be empty, or hold a list of variable names. If variable names are present, you need to enter the corresponding parameters when you execute the function. These assigned variables are available inside the function, and can be used for computations. This is called “passing variables into the function”. 13.6 Task 25 This exercise is similar to the while loop exercise. The only difference is to put the code into a function. Write a function countDown() so that you can start the countdown call from any number. For example calling countDown(5) should give: [1] “5” “4” “3” “2” “1” “0” “Lift Off!” Answer18 The scope of functions is local: this means all variables within a function are lost upon return, and global variables are not overwritten by a definition within a function. However variables that are defined outside the function are also available inside. We can use loops and control structures inside functions. For example the following creates a vector containing n Fibonacci numbers. fibSeq &lt;- function(n) { if (n &lt; 1) { return( 0 ) } else if (n == 1) { return( 1 ) } else if (n == 2) { return( c(1, 1) ) } else { v &lt;- numeric(n) v[1] &lt;- 1 v[2] &lt;- 1 for ( i in 3:n ) { v[n] &lt;- v[n-2] + v[n-1] } return( v ) } } Here is another example to play with: a function that calculates how old you are. In days. This is neat - you can celebrate your 10,000 birthday - or so. 13.7 Task 26 Copy, explore and run the below code Define the function … # A lifedays calculator function myLifeDays &lt;- function(birthday) { if (missing(birthday)) { print (&quot;Enter your birthday as a string in \\&quot;YYYY-MM-DD\\&quot; format.&quot;) return() } bd &lt;- strptime(birthday, &quot;%Y-%m-%d&quot;) # convert string to time now &lt;- format(Sys.time(), &quot;%Y-%m-%d&quot;) # convert &quot;now&quot; to time diff &lt;- round(as.numeric(difftime(now, bd, unit=&quot;days&quot;))) print(sprintf(&quot;This date was %d days ago.&quot;, diff)) } Use the function (example) myLifeDays(&quot;1932-09-25&quot;) # Glenn Gould&#39;s birthday ## [1] &quot;This date was 33702 days ago.&quot; Here is a good opportunity to practice programming: modify this function to accept a second argument. When a second argument is present (e.g. 10000) the function should print the calendar date on which the input date will be the required number of days ago. Then you could use it to know when to celebrate your 10,000th life-day, or your 777th anniversary or whatever. 13.8 Self-evaluation 13.9 Further reading, links and resources “How can I view the source code for a function?” (On Stack Overflow) If in doubt, ask! If anything about this learning unit is not clear to you, do not proceed blindly but ask for clarification. Post your question on the course mailing list: others are likely to have similar problems. Or send an email to your instructor. Author: Boris Steipe boris.steipe@utoronto.ca Created: 2017-08-05 Modified: 2019-01-07 Version: 1.0.1 Version history: 1.0.1 Maintenance 1.0 Completed to first live version 0.1 Material collected from previous tutorial 13.9.1 Updated Revision history Revision Author Date Message 5152496 Ruth Isserlin 2019-12-25 Fixed issue with task numbering because of a remove all elements call in the 2nd chapter fab47ae Ruth Isserlin 2019-12-24 initial check in of R basics book 13.9.2 Footnotes: countDown &lt;- function(n) {start &lt;- n countdown &lt;- start txt &lt;- as.character(start) while (countdown &gt; 0) { countdown &lt;- countdown - 1 txt &lt;- c(txt, countdown) } txt &lt;- c(txt,“Lift Off!”) return(txt)} countDown(7)↩︎ "],["r-plots.html", "Chapter 14 Introduction to R Plots 14.1 Overview 14.2 Task 27 14.3 Types of plots 14.4 Lines 14.5 Axes 14.6 Layout 14.7 Plot symbols and text 14.8 Drawing on plots 14.9 Special packages 14.10 Self-evaluation 14.11 Further reading, links and resources", " Chapter 14 Introduction to R Plots (Introduction to R plots) 14.1 Overview 14.1.1 Abstract: Introductory concepts and exercises for creating graphics with R. 14.1.2 Objectives: This unit will: introduce concepts of graphics for data visualization and descrptive statistics; teach basic plotting methods; 14.1.3 Outcomes: After working through this unit you: know where to find models of good data visualization; can create and customize basic plots in R; 14.1.4 Deliverables: Time management: Before you begin, estimate how long it will take you to complete this unit. Then, record in your course journal: the number of hours you estimated, the number of hours you worked on the unit, and the amount of time that passed between start and completion of this unit. Journal: Document your progress in your Course Journal. Some tasks may ask you to include specific items in your journal. Don’t overlook these. Insights: If you find something particularly noteworthy about this unit, make a note in your insights! page. 14.1.5 Prerequisites RPR-Functions (R Functions) 14.2 Task 27 Read the introductory notes on graphics in R, and some concepts of graphics for descriptive statistics. Load the R-Exercise_BasicSetup project in RStudio if you don’t already have it open. Type init() as instructed after the project has loaded. Work through the plottingIntro.R script. 14.3 Types of plots This lists the generic plots only. Many more specialized plot-types are available. plot() pie() hist() stripchart() stem() barplot() boxplot() 14.3.1 plot() ?plot ## Help on topic &#39;plot&#39; was found in the following packages: ## ## Package Library ## graphics /usr/local/lib/R/library ## base /usr/local/lib/R/library ## ## ## Using the first match ... # generate some data to plot x &lt;- rnorm(200) y &lt;- x^3 * 0.25 + rnorm(200, 0, 0.75) ?plot ## Help on topic &#39;plot&#39; was found in the following packages: ## ## Package Library ## graphics /usr/local/lib/R/library ## base /usr/local/lib/R/library ## ## ## Using the first match ... # standard scatterplot plot(x,y) plot(x,y) # Add a rug representation: rug(x) rug(y, side=2, col=&quot;red&quot;) 14.3.2 barplot() ?barplot barplot(table(round(y))) 14.3.3 hist() ?hist set.seed(12357) x &lt;- rnorm(50) hist(x, breaks=5) hist(x, breaks=5) # add a stripchart() of the actual values stripchart(x, pch=&quot;|&quot;, add=TRUE, col=&quot;red3&quot;, xlim=c(-3, 3), at=-0.5) Note: a similar plot for bivarite data is achieved with the rug() function. assigning the output of hist() makes the values used in constructing the histogram accessible: info &lt;- hist(x, breaks=5) info ## $breaks ## [1] -3 -2 -1 0 1 2 3 ## ## $counts ## [1] 1 7 21 10 10 1 ## ## $density ## [1] 0.02 0.14 0.42 0.20 0.20 0.02 ## ## $mids ## [1] -2.5 -1.5 -0.5 0.5 1.5 2.5 ## ## $xname ## [1] &quot;x&quot; ## ## $equidist ## [1] TRUE ## ## attr(,&quot;class&quot;) ## [1] &quot;histogram&quot; we can explicitly set breakpoints in a vector: * here we set them at 0.5 sigma intervals from -3 to 3 s &lt;- 1.0 hist(x, breaks=seq(-3*s, 3*s, by=0.5*s)) # we can colour the bars individually... hcol &lt;- c(&quot;#4F47FD&quot;, &quot;#6982FC&quot;, &quot;#8AA6EF&quot;, &quot;#AFBBDB&quot;, &quot;#BEBEBE&quot;, &quot;#A9A9A9&quot;, &quot;#A9A9A9&quot;, &quot;#BEBEBE&quot;, &quot;#DBBBAF&quot;, &quot;#EFA68A&quot;, &quot;#FC8269&quot;, &quot;#FD474F&quot;) # Most parameters of a generic plot apply. h &lt;- hist(x, breaks=seq(-3*s, 3*s, by=0.5*s), col=hcol, main=&quot;&quot;, xlab=expression(sigma), ylab=&quot;Counts&quot;) # ... and we can add the individual counts to the plot. text(h$mids, h$counts, h$counts, adj = c(0.5, -0.5), col = hcol) 14.3.4 boxplot ?boxplot x &lt;- rnorm(200) boxplot(x) m &lt;- x m &lt;- cbind(m, x^2) m &lt;- cbind(m, x^3) m &lt;- cbind(m, x^4) m &lt;- cbind(m, x^5) boxplot(m) boxplot(log(abs(m))) 14.3.5 Colour Colours can be specified by number, by name, as hex-triplets as rgb or hsv values, and through colour palettes. 14.3.5.1 Colours by number The col=… parameter for plots is 1 by default and you can set it to the range 0:8. 0: white 1: black (the default) 2: red 3: green 4: blue 5: cyan 6: magenta 7: yellow 8: grey barplot(rep(1,9), col=0:8, axes=FALSE, names.arg=c(0:8)) As you can see, these primary colours are decidedly garish and offend even the most rudimentary sense of aesthetics. Fortunately there are much more sophisticated ways to define colours in R. 14.3.5.2 2.2 Colours by name You may have noticed that “red”, “green”, and “blue” work for the col=… parameter, but you probably would not have imagined that “peachpuff”, “firebrick” and “goldenrod” are valid as well. In fact, there are 657 named colours in R. Access them all by typing: colors() ## [1] &quot;white&quot; &quot;aliceblue&quot; &quot;antiquewhite&quot; ## [4] &quot;antiquewhite1&quot; &quot;antiquewhite2&quot; &quot;antiquewhite3&quot; ## [7] &quot;antiquewhite4&quot; &quot;aquamarine&quot; &quot;aquamarine1&quot; ## [10] &quot;aquamarine2&quot; &quot;aquamarine3&quot; &quot;aquamarine4&quot; ## [13] &quot;azure&quot; &quot;azure1&quot; &quot;azure2&quot; ## [16] &quot;azure3&quot; &quot;azure4&quot; &quot;beige&quot; ## [19] &quot;bisque&quot; &quot;bisque1&quot; &quot;bisque2&quot; ## [22] &quot;bisque3&quot; &quot;bisque4&quot; &quot;black&quot; ## [25] &quot;blanchedalmond&quot; &quot;blue&quot; &quot;blue1&quot; ## [28] &quot;blue2&quot; &quot;blue3&quot; &quot;blue4&quot; ## [31] &quot;blueviolet&quot; &quot;brown&quot; &quot;brown1&quot; ## [34] &quot;brown2&quot; &quot;brown3&quot; &quot;brown4&quot; ## [37] &quot;burlywood&quot; &quot;burlywood1&quot; &quot;burlywood2&quot; ## [40] &quot;burlywood3&quot; &quot;burlywood4&quot; &quot;cadetblue&quot; ## [43] &quot;cadetblue1&quot; &quot;cadetblue2&quot; &quot;cadetblue3&quot; ## [46] &quot;cadetblue4&quot; &quot;chartreuse&quot; &quot;chartreuse1&quot; ## [49] &quot;chartreuse2&quot; &quot;chartreuse3&quot; &quot;chartreuse4&quot; ## [52] &quot;chocolate&quot; &quot;chocolate1&quot; &quot;chocolate2&quot; ## [55] &quot;chocolate3&quot; &quot;chocolate4&quot; &quot;coral&quot; ## [58] &quot;coral1&quot; &quot;coral2&quot; &quot;coral3&quot; ## [61] &quot;coral4&quot; &quot;cornflowerblue&quot; &quot;cornsilk&quot; ## [64] &quot;cornsilk1&quot; &quot;cornsilk2&quot; &quot;cornsilk3&quot; ## [67] &quot;cornsilk4&quot; &quot;cyan&quot; &quot;cyan1&quot; ## [70] &quot;cyan2&quot; &quot;cyan3&quot; &quot;cyan4&quot; ## [73] &quot;darkblue&quot; &quot;darkcyan&quot; &quot;darkgoldenrod&quot; ## [76] &quot;darkgoldenrod1&quot; &quot;darkgoldenrod2&quot; &quot;darkgoldenrod3&quot; ## [79] &quot;darkgoldenrod4&quot; &quot;darkgray&quot; &quot;darkgreen&quot; ## [82] &quot;darkgrey&quot; &quot;darkkhaki&quot; &quot;darkmagenta&quot; ## [85] &quot;darkolivegreen&quot; &quot;darkolivegreen1&quot; &quot;darkolivegreen2&quot; ## [88] &quot;darkolivegreen3&quot; &quot;darkolivegreen4&quot; &quot;darkorange&quot; ## [91] &quot;darkorange1&quot; &quot;darkorange2&quot; &quot;darkorange3&quot; ## [94] &quot;darkorange4&quot; &quot;darkorchid&quot; &quot;darkorchid1&quot; ## [97] &quot;darkorchid2&quot; &quot;darkorchid3&quot; &quot;darkorchid4&quot; ## [100] &quot;darkred&quot; &quot;darksalmon&quot; &quot;darkseagreen&quot; ## [103] &quot;darkseagreen1&quot; &quot;darkseagreen2&quot; &quot;darkseagreen3&quot; ## [106] &quot;darkseagreen4&quot; &quot;darkslateblue&quot; &quot;darkslategray&quot; ## [109] &quot;darkslategray1&quot; &quot;darkslategray2&quot; &quot;darkslategray3&quot; ## [112] &quot;darkslategray4&quot; &quot;darkslategrey&quot; &quot;darkturquoise&quot; ## [115] &quot;darkviolet&quot; &quot;deeppink&quot; &quot;deeppink1&quot; ## [118] &quot;deeppink2&quot; &quot;deeppink3&quot; &quot;deeppink4&quot; ## [121] &quot;deepskyblue&quot; &quot;deepskyblue1&quot; &quot;deepskyblue2&quot; ## [124] &quot;deepskyblue3&quot; &quot;deepskyblue4&quot; &quot;dimgray&quot; ## [127] &quot;dimgrey&quot; &quot;dodgerblue&quot; &quot;dodgerblue1&quot; ## [130] &quot;dodgerblue2&quot; &quot;dodgerblue3&quot; &quot;dodgerblue4&quot; ## [133] &quot;firebrick&quot; &quot;firebrick1&quot; &quot;firebrick2&quot; ## [136] &quot;firebrick3&quot; &quot;firebrick4&quot; &quot;floralwhite&quot; ## [139] &quot;forestgreen&quot; &quot;gainsboro&quot; &quot;ghostwhite&quot; ## [142] &quot;gold&quot; &quot;gold1&quot; &quot;gold2&quot; ## [145] &quot;gold3&quot; &quot;gold4&quot; &quot;goldenrod&quot; ## [148] &quot;goldenrod1&quot; &quot;goldenrod2&quot; &quot;goldenrod3&quot; ## [151] &quot;goldenrod4&quot; &quot;gray&quot; &quot;gray0&quot; ## [154] &quot;gray1&quot; &quot;gray2&quot; &quot;gray3&quot; ## [157] &quot;gray4&quot; &quot;gray5&quot; &quot;gray6&quot; ## [160] &quot;gray7&quot; &quot;gray8&quot; &quot;gray9&quot; ## [163] &quot;gray10&quot; &quot;gray11&quot; &quot;gray12&quot; ## [166] &quot;gray13&quot; &quot;gray14&quot; &quot;gray15&quot; ## [169] &quot;gray16&quot; &quot;gray17&quot; &quot;gray18&quot; ## [172] &quot;gray19&quot; &quot;gray20&quot; &quot;gray21&quot; ## [175] &quot;gray22&quot; &quot;gray23&quot; &quot;gray24&quot; ## [178] &quot;gray25&quot; &quot;gray26&quot; &quot;gray27&quot; ## [181] &quot;gray28&quot; &quot;gray29&quot; &quot;gray30&quot; ## [184] &quot;gray31&quot; &quot;gray32&quot; &quot;gray33&quot; ## [187] &quot;gray34&quot; &quot;gray35&quot; &quot;gray36&quot; ## [190] &quot;gray37&quot; &quot;gray38&quot; &quot;gray39&quot; ## [193] &quot;gray40&quot; &quot;gray41&quot; &quot;gray42&quot; ## [196] &quot;gray43&quot; &quot;gray44&quot; &quot;gray45&quot; ## [199] &quot;gray46&quot; &quot;gray47&quot; &quot;gray48&quot; ## [202] &quot;gray49&quot; &quot;gray50&quot; &quot;gray51&quot; ## [205] &quot;gray52&quot; &quot;gray53&quot; &quot;gray54&quot; ## [208] &quot;gray55&quot; &quot;gray56&quot; &quot;gray57&quot; ## [211] &quot;gray58&quot; &quot;gray59&quot; &quot;gray60&quot; ## [214] &quot;gray61&quot; &quot;gray62&quot; &quot;gray63&quot; ## [217] &quot;gray64&quot; &quot;gray65&quot; &quot;gray66&quot; ## [220] &quot;gray67&quot; &quot;gray68&quot; &quot;gray69&quot; ## [223] &quot;gray70&quot; &quot;gray71&quot; &quot;gray72&quot; ## [226] &quot;gray73&quot; &quot;gray74&quot; &quot;gray75&quot; ## [229] &quot;gray76&quot; &quot;gray77&quot; &quot;gray78&quot; ## [232] &quot;gray79&quot; &quot;gray80&quot; &quot;gray81&quot; ## [235] &quot;gray82&quot; &quot;gray83&quot; &quot;gray84&quot; ## [238] &quot;gray85&quot; &quot;gray86&quot; &quot;gray87&quot; ## [241] &quot;gray88&quot; &quot;gray89&quot; &quot;gray90&quot; ## [244] &quot;gray91&quot; &quot;gray92&quot; &quot;gray93&quot; ## [247] &quot;gray94&quot; &quot;gray95&quot; &quot;gray96&quot; ## [250] &quot;gray97&quot; &quot;gray98&quot; &quot;gray99&quot; ## [253] &quot;gray100&quot; &quot;green&quot; &quot;green1&quot; ## [256] &quot;green2&quot; &quot;green3&quot; &quot;green4&quot; ## [259] &quot;greenyellow&quot; &quot;grey&quot; &quot;grey0&quot; ## [262] &quot;grey1&quot; &quot;grey2&quot; &quot;grey3&quot; ## [265] &quot;grey4&quot; &quot;grey5&quot; &quot;grey6&quot; ## [268] &quot;grey7&quot; &quot;grey8&quot; &quot;grey9&quot; ## [271] &quot;grey10&quot; &quot;grey11&quot; &quot;grey12&quot; ## [274] &quot;grey13&quot; &quot;grey14&quot; &quot;grey15&quot; ## [277] &quot;grey16&quot; &quot;grey17&quot; &quot;grey18&quot; ## [280] &quot;grey19&quot; &quot;grey20&quot; &quot;grey21&quot; ## [283] &quot;grey22&quot; &quot;grey23&quot; &quot;grey24&quot; ## [286] &quot;grey25&quot; &quot;grey26&quot; &quot;grey27&quot; ## [289] &quot;grey28&quot; &quot;grey29&quot; &quot;grey30&quot; ## [292] &quot;grey31&quot; &quot;grey32&quot; &quot;grey33&quot; ## [295] &quot;grey34&quot; &quot;grey35&quot; &quot;grey36&quot; ## [298] &quot;grey37&quot; &quot;grey38&quot; &quot;grey39&quot; ## [301] &quot;grey40&quot; &quot;grey41&quot; &quot;grey42&quot; ## [304] &quot;grey43&quot; &quot;grey44&quot; &quot;grey45&quot; ## [307] &quot;grey46&quot; &quot;grey47&quot; &quot;grey48&quot; ## [310] &quot;grey49&quot; &quot;grey50&quot; &quot;grey51&quot; ## [313] &quot;grey52&quot; &quot;grey53&quot; &quot;grey54&quot; ## [316] &quot;grey55&quot; &quot;grey56&quot; &quot;grey57&quot; ## [319] &quot;grey58&quot; &quot;grey59&quot; &quot;grey60&quot; ## [322] &quot;grey61&quot; &quot;grey62&quot; &quot;grey63&quot; ## [325] &quot;grey64&quot; &quot;grey65&quot; &quot;grey66&quot; ## [328] &quot;grey67&quot; &quot;grey68&quot; &quot;grey69&quot; ## [331] &quot;grey70&quot; &quot;grey71&quot; &quot;grey72&quot; ## [334] &quot;grey73&quot; &quot;grey74&quot; &quot;grey75&quot; ## [337] &quot;grey76&quot; &quot;grey77&quot; &quot;grey78&quot; ## [340] &quot;grey79&quot; &quot;grey80&quot; &quot;grey81&quot; ## [343] &quot;grey82&quot; &quot;grey83&quot; &quot;grey84&quot; ## [346] &quot;grey85&quot; &quot;grey86&quot; &quot;grey87&quot; ## [349] &quot;grey88&quot; &quot;grey89&quot; &quot;grey90&quot; ## [352] &quot;grey91&quot; &quot;grey92&quot; &quot;grey93&quot; ## [355] &quot;grey94&quot; &quot;grey95&quot; &quot;grey96&quot; ## [358] &quot;grey97&quot; &quot;grey98&quot; &quot;grey99&quot; ## [361] &quot;grey100&quot; &quot;honeydew&quot; &quot;honeydew1&quot; ## [364] &quot;honeydew2&quot; &quot;honeydew3&quot; &quot;honeydew4&quot; ## [367] &quot;hotpink&quot; &quot;hotpink1&quot; &quot;hotpink2&quot; ## [370] &quot;hotpink3&quot; &quot;hotpink4&quot; &quot;indianred&quot; ## [373] &quot;indianred1&quot; &quot;indianred2&quot; &quot;indianred3&quot; ## [376] &quot;indianred4&quot; &quot;ivory&quot; &quot;ivory1&quot; ## [379] &quot;ivory2&quot; &quot;ivory3&quot; &quot;ivory4&quot; ## [382] &quot;khaki&quot; &quot;khaki1&quot; &quot;khaki2&quot; ## [385] &quot;khaki3&quot; &quot;khaki4&quot; &quot;lavender&quot; ## [388] &quot;lavenderblush&quot; &quot;lavenderblush1&quot; &quot;lavenderblush2&quot; ## [391] &quot;lavenderblush3&quot; &quot;lavenderblush4&quot; &quot;lawngreen&quot; ## [394] &quot;lemonchiffon&quot; &quot;lemonchiffon1&quot; &quot;lemonchiffon2&quot; ## [397] &quot;lemonchiffon3&quot; &quot;lemonchiffon4&quot; &quot;lightblue&quot; ## [400] &quot;lightblue1&quot; &quot;lightblue2&quot; &quot;lightblue3&quot; ## [403] &quot;lightblue4&quot; &quot;lightcoral&quot; &quot;lightcyan&quot; ## [406] &quot;lightcyan1&quot; &quot;lightcyan2&quot; &quot;lightcyan3&quot; ## [409] &quot;lightcyan4&quot; &quot;lightgoldenrod&quot; &quot;lightgoldenrod1&quot; ## [412] &quot;lightgoldenrod2&quot; &quot;lightgoldenrod3&quot; &quot;lightgoldenrod4&quot; ## [415] &quot;lightgoldenrodyellow&quot; &quot;lightgray&quot; &quot;lightgreen&quot; ## [418] &quot;lightgrey&quot; &quot;lightpink&quot; &quot;lightpink1&quot; ## [421] &quot;lightpink2&quot; &quot;lightpink3&quot; &quot;lightpink4&quot; ## [424] &quot;lightsalmon&quot; &quot;lightsalmon1&quot; &quot;lightsalmon2&quot; ## [427] &quot;lightsalmon3&quot; &quot;lightsalmon4&quot; &quot;lightseagreen&quot; ## [430] &quot;lightskyblue&quot; &quot;lightskyblue1&quot; &quot;lightskyblue2&quot; ## [433] &quot;lightskyblue3&quot; &quot;lightskyblue4&quot; &quot;lightslateblue&quot; ## [436] &quot;lightslategray&quot; &quot;lightslategrey&quot; &quot;lightsteelblue&quot; ## [439] &quot;lightsteelblue1&quot; &quot;lightsteelblue2&quot; &quot;lightsteelblue3&quot; ## [442] &quot;lightsteelblue4&quot; &quot;lightyellow&quot; &quot;lightyellow1&quot; ## [445] &quot;lightyellow2&quot; &quot;lightyellow3&quot; &quot;lightyellow4&quot; ## [448] &quot;limegreen&quot; &quot;linen&quot; &quot;magenta&quot; ## [451] &quot;magenta1&quot; &quot;magenta2&quot; &quot;magenta3&quot; ## [454] &quot;magenta4&quot; &quot;maroon&quot; &quot;maroon1&quot; ## [457] &quot;maroon2&quot; &quot;maroon3&quot; &quot;maroon4&quot; ## [460] &quot;mediumaquamarine&quot; &quot;mediumblue&quot; &quot;mediumorchid&quot; ## [463] &quot;mediumorchid1&quot; &quot;mediumorchid2&quot; &quot;mediumorchid3&quot; ## [466] &quot;mediumorchid4&quot; &quot;mediumpurple&quot; &quot;mediumpurple1&quot; ## [469] &quot;mediumpurple2&quot; &quot;mediumpurple3&quot; &quot;mediumpurple4&quot; ## [472] &quot;mediumseagreen&quot; &quot;mediumslateblue&quot; &quot;mediumspringgreen&quot; ## [475] &quot;mediumturquoise&quot; &quot;mediumvioletred&quot; &quot;midnightblue&quot; ## [478] &quot;mintcream&quot; &quot;mistyrose&quot; &quot;mistyrose1&quot; ## [481] &quot;mistyrose2&quot; &quot;mistyrose3&quot; &quot;mistyrose4&quot; ## [484] &quot;moccasin&quot; &quot;navajowhite&quot; &quot;navajowhite1&quot; ## [487] &quot;navajowhite2&quot; &quot;navajowhite3&quot; &quot;navajowhite4&quot; ## [490] &quot;navy&quot; &quot;navyblue&quot; &quot;oldlace&quot; ## [493] &quot;olivedrab&quot; &quot;olivedrab1&quot; &quot;olivedrab2&quot; ## [496] &quot;olivedrab3&quot; &quot;olivedrab4&quot; &quot;orange&quot; ## [499] &quot;orange1&quot; &quot;orange2&quot; &quot;orange3&quot; ## [502] &quot;orange4&quot; &quot;orangered&quot; &quot;orangered1&quot; ## [505] &quot;orangered2&quot; &quot;orangered3&quot; &quot;orangered4&quot; ## [508] &quot;orchid&quot; &quot;orchid1&quot; &quot;orchid2&quot; ## [511] &quot;orchid3&quot; &quot;orchid4&quot; &quot;palegoldenrod&quot; ## [514] &quot;palegreen&quot; &quot;palegreen1&quot; &quot;palegreen2&quot; ## [517] &quot;palegreen3&quot; &quot;palegreen4&quot; &quot;paleturquoise&quot; ## [520] &quot;paleturquoise1&quot; &quot;paleturquoise2&quot; &quot;paleturquoise3&quot; ## [523] &quot;paleturquoise4&quot; &quot;palevioletred&quot; &quot;palevioletred1&quot; ## [526] &quot;palevioletred2&quot; &quot;palevioletred3&quot; &quot;palevioletred4&quot; ## [529] &quot;papayawhip&quot; &quot;peachpuff&quot; &quot;peachpuff1&quot; ## [532] &quot;peachpuff2&quot; &quot;peachpuff3&quot; &quot;peachpuff4&quot; ## [535] &quot;peru&quot; &quot;pink&quot; &quot;pink1&quot; ## [538] &quot;pink2&quot; &quot;pink3&quot; &quot;pink4&quot; ## [541] &quot;plum&quot; &quot;plum1&quot; &quot;plum2&quot; ## [544] &quot;plum3&quot; &quot;plum4&quot; &quot;powderblue&quot; ## [547] &quot;purple&quot; &quot;purple1&quot; &quot;purple2&quot; ## [550] &quot;purple3&quot; &quot;purple4&quot; &quot;red&quot; ## [553] &quot;red1&quot; &quot;red2&quot; &quot;red3&quot; ## [556] &quot;red4&quot; &quot;rosybrown&quot; &quot;rosybrown1&quot; ## [559] &quot;rosybrown2&quot; &quot;rosybrown3&quot; &quot;rosybrown4&quot; ## [562] &quot;royalblue&quot; &quot;royalblue1&quot; &quot;royalblue2&quot; ## [565] &quot;royalblue3&quot; &quot;royalblue4&quot; &quot;saddlebrown&quot; ## [568] &quot;salmon&quot; &quot;salmon1&quot; &quot;salmon2&quot; ## [571] &quot;salmon3&quot; &quot;salmon4&quot; &quot;sandybrown&quot; ## [574] &quot;seagreen&quot; &quot;seagreen1&quot; &quot;seagreen2&quot; ## [577] &quot;seagreen3&quot; &quot;seagreen4&quot; &quot;seashell&quot; ## [580] &quot;seashell1&quot; &quot;seashell2&quot; &quot;seashell3&quot; ## [583] &quot;seashell4&quot; &quot;sienna&quot; &quot;sienna1&quot; ## [586] &quot;sienna2&quot; &quot;sienna3&quot; &quot;sienna4&quot; ## [589] &quot;skyblue&quot; &quot;skyblue1&quot; &quot;skyblue2&quot; ## [592] &quot;skyblue3&quot; &quot;skyblue4&quot; &quot;slateblue&quot; ## [595] &quot;slateblue1&quot; &quot;slateblue2&quot; &quot;slateblue3&quot; ## [598] &quot;slateblue4&quot; &quot;slategray&quot; &quot;slategray1&quot; ## [601] &quot;slategray2&quot; &quot;slategray3&quot; &quot;slategray4&quot; ## [604] &quot;slategrey&quot; &quot;snow&quot; &quot;snow1&quot; ## [607] &quot;snow2&quot; &quot;snow3&quot; &quot;snow4&quot; ## [610] &quot;springgreen&quot; &quot;springgreen1&quot; &quot;springgreen2&quot; ## [613] &quot;springgreen3&quot; &quot;springgreen4&quot; &quot;steelblue&quot; ## [616] &quot;steelblue1&quot; &quot;steelblue2&quot; &quot;steelblue3&quot; ## [619] &quot;steelblue4&quot; &quot;tan&quot; &quot;tan1&quot; ## [622] &quot;tan2&quot; &quot;tan3&quot; &quot;tan4&quot; ## [625] &quot;thistle&quot; &quot;thistle1&quot; &quot;thistle2&quot; ## [628] &quot;thistle3&quot; &quot;thistle4&quot; &quot;tomato&quot; ## [631] &quot;tomato1&quot; &quot;tomato2&quot; &quot;tomato3&quot; ## [634] &quot;tomato4&quot; &quot;turquoise&quot; &quot;turquoise1&quot; ## [637] &quot;turquoise2&quot; &quot;turquoise3&quot; &quot;turquoise4&quot; ## [640] &quot;violet&quot; &quot;violetred&quot; &quot;violetred1&quot; ## [643] &quot;violetred2&quot; &quot;violetred3&quot; &quot;violetred4&quot; ## [646] &quot;wheat&quot; &quot;wheat1&quot; &quot;wheat2&quot; ## [649] &quot;wheat3&quot; &quot;wheat4&quot; &quot;whitesmoke&quot; ## [652] &quot;yellow&quot; &quot;yellow1&quot; &quot;yellow2&quot; ## [655] &quot;yellow3&quot; &quot;yellow4&quot; &quot;yellowgreen&quot; pie(c(1, 1, 2, 3, 5, 8, 13), col=c( &quot;firebrick2&quot;, &quot;tomato&quot;, &quot;goldenrod1&quot;, &quot;peachpuff&quot;, &quot;papayawhip&quot;, &quot;seashell&quot;, &quot;whitesmoke&quot; ) ) Read more about named colours (and related topics) here 14.3.5.3 Colours as hex-triplets Hex triplets in R work exactly as in HTML: a triplet of RGB values in two-digit hexadecimal representation. The first two digits specify the red value, the second two are for green, then blue. R accepts a fourth pair of digits to optionally specify the transparency, the semantics of the code is thus “#RRGGBB” or “#RRGGBBAA”. Read more e.g. at http://en.wikipedia.org/wiki/Web_colors # The function col2rgb() converts colour names to rgb values ... col2rgb(&quot;violetred&quot;) ## [,1] ## red 208 ## green 32 ## blue 144 # ... and rgb() converts rgb values to hex-code: rgb(1, 0.5, 0.23) ## [1] &quot;#FF803B&quot; Unfortunately the output of col2rgb does not quite match rgb(). col2rgb creates rows with values between 0 and 255, and rgb by default expects columns with intensities from 0 to 1, you have to transpose and divide. rgb(t(col2rgb(&quot;red&quot;))/255) # &quot;#FF0000&quot; ## [1] &quot;#FF0000&quot; rgb(t(col2rgb(&quot;peachpuff&quot;))/255) # &quot;#FFDAB9&quot; ## [1] &quot;#FFDAB9&quot; There are many tools on the Web that help to generate pleasing palettes. Here is an example -“Creative Cloud”- taken from https://kuler.adobe.com/ CC &lt;- c(&quot;#011640&quot;, &quot;#024059&quot;, &quot;#F2F0D0&quot;, &quot;#BE6C5C&quot;, &quot;#8C3037&quot; ) hist(rnorm(1000), breaks=20 , col=CC) R colours are actually specified as quartets: the fourth value the “Alpha channel” defines the transparency. Setting this to values other than “FF” (the default) can be useful for very crowded plots, or for creating overlays. x &lt;- rnorm(2000) y &lt;- x^3 * 0.25 + rnorm(2000, 0, 0.75) compare: plot(x,y, pch = 19, col = &quot;#EE3A8C&quot;) And plot(x,y, pch = 19, col = &quot;#EE3A8C12&quot;) # Alpha at ~ 10% or with multiple overlays of varying size using points() … plot( x,y, pch = 16, cex = 1, col = &quot;#AA330009&quot;) plot(x,y, pch = 19, cex = 2, col = &quot;#44558803&quot;) plot(x,y, pch = 20, cex = 0.5, col = &quot;#EE3A8C08&quot;) A similar behaviour can be obtained from “density adapted colors with the densCols() function plot (x, y, col = densCols(x, y), pch = 19, cex = 1.5) 14.3.6 Colour palettes R has several inbuilt colour palettes, or you can build your own. # Inbuilt palettes ?rainbow view the palettes opar &lt;- par(mfrow=c(3,2)) n &lt;- 20 sq &lt;- rep(1, n) barplot(sq, col=rainbow(n), axes=F, main=&quot;rainbow(n)&quot;) barplot(sq, col=cm.colors(n), axes=F, main=&quot;cm.colors(n)&quot;) barplot(sq, col=topo.colors(n), axes=F, main=&quot;topo.colors(n)&quot;) barplot(sq, col=terrain.colors(n), axes=F, main=&quot;terrain.colors(n)&quot;) barplot(sq, col=heat.colors(n), axes=F, main=&quot;heat.colors(n)&quot;) par &lt;- opar Useful palettes have also been described specifically for cartography. Colorbrewer2 has palettes for seqential and qualitative diferences, and options for colourblind-safe and photocopy friendly palettes. You can use them via an R package: if (!require(RColorBrewer, quietly=TRUE)) { install.packages(&quot;RColorBrewer&quot;) library(RColorBrewer) } display.brewer.all() Here, we apply a Brewer palette to a Voronoi tesselation of a point set. if (!require(deldir, quietly=TRUE)) { install.packages(&quot;deldir&quot;) library(deldir) } ## deldir 2.0-4 Nickname: &quot;Idol Comparison&quot; ## ## The syntax of deldir() has changed since version ## 0.0-10. Read the help!!!. Create a point set along a logarithmic spiral, with a bit of added noise. li &lt;- 0.1 n &lt;- 45 dl &lt;- 1.06 ncirc &lt;- 13 da &lt;- (2*pi)/ncirc fnoise &lt;-0.13 create a matrix of points x &lt;- numeric(n) x &lt;- cbind(x, numeric(n)) set.seed(16180) for (i in 1:n) { l &lt;- li * (dl^(i-1)) x[i,1] &lt;- (l+(rnorm(1)*fnoise*l)) * cos((i-1)*da) x[i,2] &lt;- (l+(rnorm(1)*fnoise*l)) * sin((i-1)*da) } plot(x[,1], x[,2]) ts &lt;- deldir(x[,1], x[,2]) # calculate the tesselation tl &lt;- tile.list(ts) # calculate the list of tiles plot.tile.list(tl) # plot it Let’s colour the cells by distance from a defined point using a Brewer palette plot.tile.list(tl) # plot it points(x[25,1], x[25,2], pch=20, col=&quot;red&quot;) # pick a point vec &lt;- c(x[25,1], x[25,2]) # define a point define a function for Euclidian distance vDist &lt;- function(x,v) { sqrt(sum((x-v)^2)) } # calculates Euclidian distance d &lt;- apply(x, 1 , vDist, v=vec) # apply this to the point set dCol &lt;- floor(((d-min(d))/(max(d)-min(d)) * 10)) + 1 # map d into 10 intervals dCol[which(dCol&gt;10)] &lt;- 10 # demote the largest one pal &lt;- brewer.pal(10, &quot;RdGy&quot;) # create the palette # plot the tesselation, colour by palette plot.tile.list(tl, fillcol = pal[dCol], cex=0.8, pch=20, col.pts=&quot;slategrey&quot;) 14.4 Lines Basically all plots take arguments lty to define the line type, and lwd to define line width # empty plot ... plot(c(0,10), c(0,10), type = &quot;n&quot;, axes = FALSE, xlab = &quot;&quot;, ylab = &quot;&quot;) # Line type for (i in 1:8) { y &lt;- 10.5-(i/2) segments(1,y,5,y, lty=i) text(6, y, paste(&quot;lty = &quot;, i), col=&quot;grey60&quot;, adj=0, cex=0.75) } # Line width for (i in 1:10) { y &lt;- 5.5-(i/2) segments(1,y,5,y, lwd=(0.3*i)^2) text(6, y, paste(&quot;lwd = &quot;, (0.3*i)^2), col=&quot;grey60&quot;, adj=0, cex=0.75) } 14.5 Axes # For Details, see: ?plot.default n &lt;- 1000 x &lt;- rnorm(n) y &lt;- x^3 * 0.25 + rnorm(n, sd=0.75) plot(x,y) # Default plot(x,y, xlim=c(-4, 4)) # fixed limits plot(x,y, xlim=c(-4, 4), ylim=c(10, -10)) # reverse is possible plot(x,y, log=&quot;xy&quot;) # log axes ## Warning in xy.coords(x, y, xlabel, ylabel, log): 498 x values &lt;= 0 omitted from ## logarithmic plot ## Warning in xy.coords(x, y, xlabel, ylabel, log): 484 y values &lt;= 0 omitted from ## logarithmic plot The axis parameters in the default plot are limited. If you want more control, suppress the printing of an axis in the plot and use the axis() function instead. ?axis # Axis-labels and title are straightforward parameters of plot plot(x,y, xlab=&quot;rnorm(n)&quot;, ylab=&quot;x^3 * 0.25 + rnorm(n, sd=0.75)&quot;, cex.main=1.3, main=&quot;Sample\\nPlot&quot;, cex.sub=0.75, col.sub=&quot;grey&quot;, sub=&quot;Scatterplot of noisy 3d-degree polynomial&quot; ) Add gridlines ?grid plot(x,y, xlab=&quot;rnorm(n)&quot;, ylab=&quot;x^3 * 0.25 + rnorm(n, sd=0.75)&quot;, cex.main=1.3, main=&quot;Sample\\nPlot&quot;, cex.sub=0.75, col.sub=&quot;grey&quot;, sub=&quot;Scatterplot of noisy 3d-degree polynomial&quot; ) grid() 14.6 Layout 14.6.1 par, lattice, constant aspect ratio Most parameters of the plot window can be set via the functions plot(), hist() etc., but some need to be set via the par() function. Calling par() without arguments lists the current state of the plotting parameters. Calling it with arguments, returns the old parameters and sets new parameters. Thus setting new parameters and saving the old ones can be done in one step. The parameters that have to be set via par include: multiple plots in one window (mfrow, mfcol, mfg) margin layout (mai, mar mex, oma, omd, omi) controlling position and size of a plot in the figure (fig, plt, ps, pty) see ?par for details. n &lt;- 1000 x &lt;- rnorm(n) y &lt;- x^3 * 0.25 + rnorm(n, sd=0.75) # set window background and plotting axes via par opar &lt;- par(bg=&quot;steelblue&quot;, fg=&quot;lightyellow&quot;) # set axis lables and titles via plot parameters plot(x,y, col.axis=&quot;lightyellow&quot;, col.lab=&quot;lightyellow&quot;) par(opar) # rest to old values plot(x,y) # confirm reset 14.7 Plot symbols and text Plot symbols are defined in the pch argument to plot(). id 1:20 are regular symbols # Empty plot frame ... plot(c(0,10), c(0,10), type = &quot;n&quot;, axes = FALSE, xlab = &quot;&quot;, ylab = &quot;&quot;) # coordinates for first 25 symbols x1 &lt;- rep(0.5:9.5, 2)[1:20] y1 &lt;- sort(rep(9.5:8.5, 10), dec=TRUE)[1:20] points(x1, y1, pch=1:20) # Empty plot frame ... plot(c(0,10), c(0,10), type = &quot;n&quot;, axes = FALSE, xlab = &quot;&quot;, ylab = &quot;&quot;) # id 21:25 can have different border and fill colours x2 &lt;- 0.5:4.5 y2 &lt;- rep(7.5,5) points(x2, y2, pch=21:25, col=&quot;slategrey&quot;, bg=rainbow(5)) # Empty plot frame ... plot(c(0,10), c(0,10), type = &quot;n&quot;, axes = FALSE, xlab = &quot;&quot;, ylab = &quot;&quot;) # ten extra symbols are defined as characters x3 &lt;- 0.5:9.5 y3 &lt;- rep(6.5,10) extra = c(&quot;.&quot;, &quot;o&quot;, &quot;O&quot;, &quot;0&quot;,&quot;a&quot;,&quot;A&quot;, &quot;*&quot;, &quot;+&quot;,&quot;-&quot;,&quot;|&quot;) points(x3, y3, pch=extra) # note: ext is a character vector # Empty plot frame ... plot(c(0,10), c(0,10), type = &quot;n&quot;, axes = FALSE, xlab = &quot;&quot;, ylab = &quot;&quot;) # The ASCII codes for characters 32 to 126 can also be used as plotting symbols x4 &lt;- rep(seq(0.5,9.5,0.5), 5)[1:96] y4 &lt;- sort(rep(5.5:0.5, 19), dec=TRUE)[1:96] points(x4, y4, pch=32:126, col=&quot;navyblue&quot;) Plotting arbitrary text use the text() function to plot characters and strings to coordinates ?text # Empty plot frame ... plot(c(0,10), c(0,10), type = &quot;n&quot;, axes = FALSE, xlab = &quot;&quot;, ylab = &quot;&quot;) # Example: add labels to the symbols # first set: plain symbols (1 to 20) text(x1-0.4, y1, paste(1:20), cex=0.75) # symbols with separate background (21 to 25) text(x2-0.4, y2, paste(21:25), cex=0.75) # third set: special characters, change font for clarity text(x3-0.4, y3, extra, col=&quot;slateblue&quot;, cex=0.75, vfont=c(&quot;serif&quot;, &quot;plain&quot;)) a large set of Hershey vector fonts is available which gives access to many more plotting and labeling options via text() demo(Hershey) ## ## ## demo(Hershey) ## ---- ~~~~~~~ ## ## &gt; # Copyright (C) 2003-2009 The R Core Team ## &gt; ## &gt; #### --- Hershey Vector Fonts --- ## &gt; ## &gt; require(grDevices); require(graphics) ## ## &gt; ###### ## &gt; # create tables of vector font functionality ## &gt; ###### ## &gt; make.table &lt;- function(nr, nc) { ## + savepar &lt;- par(mar=rep(0, 4), pty=&quot;s&quot;) ## + plot(c(0, nc*2 + 1), c(0, -(nr + 1)), ## + type=&quot;n&quot;, xlab=&quot;&quot;, ylab=&quot;&quot;, axes=FALSE) ## + invisible(savepar) ## + } ## ## &gt; get.r &lt;- function(i, nr) i %% nr + 1 ## ## &gt; get.c &lt;- function(i, nr) i %/% nr + 1 ## ## &gt; draw.title &lt;- function(title, i = 0, nr, nc) { ## + r &lt;- get.r(i, nr) ## + c &lt;- get.c(i, nr) ## + text((nc*2 + 1)/2, 0, title, font=2) ## + } ## ## &gt; draw.sample.cell &lt;- function(typeface, fontindex, string, i, nr) { ## + r &lt;- get.r(i, nr) ## + c &lt;- get.c(i, nr) ## + text(2*(c - 1) + 1, -r, paste(typeface, fontindex)) ## + text(2*c, -r, string, vfont=c(typeface, fontindex), cex=1.5) ## + rect(2*(c - 1) + .5, -(r - .5), 2*c + .5, -(r + .5), border=&quot;grey&quot;) ## + } ## ## &gt; draw.vf.cell &lt;- function(typeface, fontindex, string, i, nr, raw.string=NULL) { ## + r &lt;- get.r(i, nr) ## + c &lt;- get.c(i, nr) ## + if (is.null(raw.string)) ## + raw.string &lt;- paste(&quot;\\\\&quot;, string, sep=&quot;&quot;) ## + text(2*(c - 1) + 1, -r, raw.string, col=&quot;grey&quot;) ## + text(2*c, -r, string, vfont=c(typeface, fontindex)) ## + rect(2*(c - 1) + .5, -(r - .5), (2*c + .5), -(r + .5), border=&quot;grey&quot;) ## + } ## ## &gt; nr &lt;- 23 ## ## &gt; nc &lt;- 1 ## ## &gt; oldpar &lt;- make.table(nr, nc) ## ## &gt; i &lt;- 0 ## ## &gt; draw.title(&quot;Sample &#39;a&#39; for each available font&quot;, i, nr, nc) ## ## &gt; draw.sample.cell(&quot;serif&quot;, &quot;plain&quot;, &quot;a&quot;, i, nr); i &lt;- i + 1 ## ## &gt; draw.sample.cell(&quot;serif&quot;, &quot;italic&quot;, &quot;a&quot;, i, nr); i &lt;- i + 1 ## ## &gt; draw.sample.cell(&quot;serif&quot;, &quot;bold&quot;, &quot;a&quot;, i, nr); i &lt;- i + 1 ## ## &gt; draw.sample.cell(&quot;serif&quot;, &quot;bold italic&quot;, &quot;a&quot;, i, nr); i &lt;- i + 1 ## ## &gt; draw.sample.cell(&quot;serif&quot;, &quot;cyrillic&quot;, &quot;\\301&quot;, i, nr); i &lt;- i + 1 ## ## &gt; draw.sample.cell(&quot;serif&quot;, &quot;oblique cyrillic&quot;, &quot;\\301&quot;, i, nr); i &lt;- i + 1 ## ## &gt; draw.sample.cell(&quot;serif&quot;, &quot;EUC&quot;, &quot;a&quot;, i, nr); i &lt;- i + 1 ## ## &gt; draw.sample.cell(&quot;sans serif&quot;, &quot;plain&quot;, &quot;a&quot;, i, nr); i &lt;- i + 1 ## ## &gt; draw.sample.cell(&quot;sans serif&quot;, &quot;italic&quot;, &quot;a&quot;, i, nr); i &lt;- i + 1 ## ## &gt; draw.sample.cell(&quot;sans serif&quot;, &quot;bold&quot;, &quot;a&quot;, i, nr); i &lt;- i + 1 ## ## &gt; draw.sample.cell(&quot;sans serif&quot;, &quot;bold italic&quot;, &quot;a&quot;, i, nr); i &lt;- i + 1 ## ## &gt; draw.sample.cell(&quot;script&quot;, &quot;plain&quot;, &quot;a&quot;, i, nr); i &lt;- i + 1 ## ## &gt; draw.sample.cell(&quot;script&quot;, &quot;italic&quot;, &quot;a&quot;, i, nr); i &lt;- i + 1 ## ## &gt; draw.sample.cell(&quot;script&quot;, &quot;bold&quot;, &quot;a&quot;, i, nr); i &lt;- i + 1 ## ## &gt; draw.sample.cell(&quot;gothic english&quot;, &quot;plain&quot;, &quot;a&quot;, i, nr); i &lt;- i + 1 ## ## &gt; draw.sample.cell(&quot;gothic german&quot;, &quot;plain&quot;, &quot;a&quot;, i, nr); i &lt;- i + 1 ## ## &gt; draw.sample.cell(&quot;gothic italian&quot;, &quot;plain&quot;, &quot;a&quot;, i, nr); i &lt;- i + 1 ## ## &gt; draw.sample.cell(&quot;serif symbol&quot;, &quot;plain&quot;, &quot;a&quot;, i, nr); i &lt;- i + 1 ## ## &gt; draw.sample.cell(&quot;serif symbol&quot;, &quot;italic&quot;, &quot;a&quot;, i, nr); i &lt;- i + 1 ## ## &gt; draw.sample.cell(&quot;serif symbol&quot;, &quot;bold&quot;, &quot;a&quot;, i, nr); i &lt;- i + 1 ## ## &gt; draw.sample.cell(&quot;serif symbol&quot;, &quot;bold italic&quot;, &quot;a&quot;, i, nr); i &lt;- i + 1 ## ## &gt; draw.sample.cell(&quot;sans serif symbol&quot;, &quot;plain&quot;, &quot;a&quot;, i, nr); i &lt;- i + 1 ## ## &gt; draw.sample.cell(&quot;sans serif symbol&quot;, &quot;italic&quot;, &quot;a&quot;, i, nr); i &lt;- i + 1 ## ## &gt; nr &lt;- 25 ## ## &gt; nc &lt;- 6 ## ## &gt; tf &lt;- &quot;serif&quot; ## ## &gt; fi &lt;- &quot;plain&quot; ## ## &gt; make.table(nr, nc) ## ## &gt; i &lt;- 0 ## ## &gt; draw.title(&quot;Symbol (incl. Greek) Escape Sequences&quot;, i, nr, nc) ## ## &gt; ## Greek alphabet in order ## &gt; draw.vf.cell(tf, fi, &quot;\\\\*A&quot;, i, nr); i&lt;-i+1; { &quot;Alpha&quot;} ## [1] &quot;Alpha&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\*B&quot;, i, nr); i&lt;-i+1; { &quot;Beta&quot;} ## [1] &quot;Beta&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\*G&quot;, i, nr); i&lt;-i+1; { &quot;Gamma&quot;} ## [1] &quot;Gamma&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\*D&quot;, i, nr); i&lt;-i+1; { &quot;Delta&quot;} ## [1] &quot;Delta&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\*E&quot;, i, nr); i&lt;-i+1; { &quot;Epsilon&quot;} ## [1] &quot;Epsilon&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\*Z&quot;, i, nr); i&lt;-i+1; { &quot;Zeta&quot;} ## [1] &quot;Zeta&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\*Y&quot;, i, nr); i&lt;-i+1; { &quot;Eta&quot;} ## [1] &quot;Eta&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\*H&quot;, i, nr); i&lt;-i+1; { &quot;Theta&quot;} ## [1] &quot;Theta&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\*I&quot;, i, nr); i&lt;-i+1; { &quot;Iota&quot;} ## [1] &quot;Iota&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\*K&quot;, i, nr); i&lt;-i+1; { &quot;Kappa&quot;} ## [1] &quot;Kappa&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\*L&quot;, i, nr); i&lt;-i+1; { &quot;Lambda&quot;} ## [1] &quot;Lambda&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\*M&quot;, i, nr); i&lt;-i+1; { &quot;Mu&quot;} ## [1] &quot;Mu&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\*N&quot;, i, nr); i&lt;-i+1; { &quot;Nu&quot;} ## [1] &quot;Nu&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\*C&quot;, i, nr); i&lt;-i+1; { &quot;Xi&quot;} ## [1] &quot;Xi&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\*O&quot;, i, nr); i&lt;-i+1; { &quot;Omicron&quot;} ## [1] &quot;Omicron&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\*P&quot;, i, nr); i&lt;-i+1; { &quot;Pi&quot;} ## [1] &quot;Pi&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\*R&quot;, i, nr); i&lt;-i+1; { &quot;Rho&quot;} ## [1] &quot;Rho&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\*S&quot;, i, nr); i&lt;-i+1; { &quot;Sigma&quot;} ## [1] &quot;Sigma&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\*T&quot;, i, nr); i&lt;-i+1; { &quot;Tau&quot;} ## [1] &quot;Tau&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\*U&quot;, i, nr); i&lt;-i+1; { &quot;Upsilon&quot;} ## [1] &quot;Upsilon&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\+U&quot;, i, nr); i&lt;-i+1; { &quot;Upsilon1&quot;} ## [1] &quot;Upsilon1&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\*F&quot;, i, nr); i&lt;-i+1; { &quot;Phi&quot;} ## [1] &quot;Phi&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\*X&quot;, i, nr); i&lt;-i+1; { &quot;Chi&quot;} ## [1] &quot;Chi&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\*Q&quot;, i, nr); i&lt;-i+1; { &quot;Psi&quot;} ## [1] &quot;Psi&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\*W&quot;, i, nr); i&lt;-i+1; { &quot;Omega&quot;} ## [1] &quot;Omega&quot; ## ## &gt; # ## &gt; draw.vf.cell(tf, fi, &quot;\\\\*a&quot;, i, nr); i&lt;-i+1; { &quot;alpha&quot;} ## [1] &quot;alpha&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\*b&quot;, i, nr); i&lt;-i+1; { &quot;beta&quot;} ## [1] &quot;beta&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\*g&quot;, i, nr); i&lt;-i+1; { &quot;gamma&quot;} ## [1] &quot;gamma&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\*d&quot;, i, nr); i&lt;-i+1; { &quot;delta&quot;} ## [1] &quot;delta&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\*e&quot;, i, nr); i&lt;-i+1; { &quot;epsilon&quot;} ## [1] &quot;epsilon&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\*z&quot;, i, nr); i&lt;-i+1; { &quot;zeta&quot;} ## [1] &quot;zeta&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\*y&quot;, i, nr); i&lt;-i+1; { &quot;eta&quot;} ## [1] &quot;eta&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\*h&quot;, i, nr); i&lt;-i+1; { &quot;theta&quot;} ## [1] &quot;theta&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\+h&quot;, i, nr); i&lt;-i+1; { &quot;theta1&quot;} ## [1] &quot;theta1&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\*i&quot;, i, nr); i&lt;-i+1; { &quot;iota&quot;} ## [1] &quot;iota&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\*k&quot;, i, nr); i&lt;-i+1; { &quot;kappa&quot;} ## [1] &quot;kappa&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\*l&quot;, i, nr); i&lt;-i+1; { &quot;lambda&quot;} ## [1] &quot;lambda&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\*m&quot;, i, nr); i&lt;-i+1; { &quot;mu&quot;} ## [1] &quot;mu&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\*n&quot;, i, nr); i&lt;-i+1; { &quot;nu&quot;} ## [1] &quot;nu&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\*c&quot;, i, nr); i&lt;-i+1; { &quot;xi&quot;} ## [1] &quot;xi&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\*o&quot;, i, nr); i&lt;-i+1; { &quot;omicron&quot;} ## [1] &quot;omicron&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\*p&quot;, i, nr); i&lt;-i+1; { &quot;pi&quot;} ## [1] &quot;pi&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\*r&quot;, i, nr); i&lt;-i+1; { &quot;rho&quot;} ## [1] &quot;rho&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\*s&quot;, i, nr); i&lt;-i+1; { &quot;sigma&quot;} ## [1] &quot;sigma&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\ts&quot;, i, nr); i&lt;-i+1; { &quot;sigma1&quot;} ## [1] &quot;sigma1&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\*t&quot;, i, nr); i&lt;-i+1; { &quot;tau&quot;} ## [1] &quot;tau&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\*u&quot;, i, nr); i&lt;-i+1; { &quot;upsilon&quot;} ## [1] &quot;upsilon&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\*f&quot;, i, nr); i&lt;-i+1; { &quot;phi&quot;} ## [1] &quot;phi&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\+f&quot;, i, nr); i&lt;-i+1; { &quot;phi1&quot;} ## [1] &quot;phi1&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\*x&quot;, i, nr); i&lt;-i+1; { &quot;chi&quot;} ## [1] &quot;chi&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\*q&quot;, i, nr); i&lt;-i+1; { &quot;psi&quot;} ## [1] &quot;psi&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\*w&quot;, i, nr); i&lt;-i+1; { &quot;omega&quot;} ## [1] &quot;omega&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\+p&quot;, i, nr); i&lt;-i+1; { &quot;omega1&quot;} ## [1] &quot;omega1&quot; ## ## &gt; # ## &gt; draw.vf.cell(tf, fi, &quot;\\\\fa&quot;, i, nr); i&lt;-i+1; { &quot;universal&quot;} ## [1] &quot;universal&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\te&quot;, i, nr); i&lt;-i+1; { &quot;existential&quot;} ## [1] &quot;existential&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\st&quot;, i, nr); i&lt;-i+1; { &quot;suchthat&quot;} ## [1] &quot;suchthat&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\**&quot;, i, nr); i&lt;-i+1; { &quot;asteriskmath&quot;} ## [1] &quot;asteriskmath&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\=~&quot;, i, nr); i&lt;-i+1; { &quot;congruent&quot;} ## [1] &quot;congruent&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\tf&quot;, i, nr); i&lt;-i+1; { &quot;therefore&quot;} ## [1] &quot;therefore&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\pp&quot;, i, nr); i&lt;-i+1; { &quot;perpendicular&quot;} ## [1] &quot;perpendicular&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\ul&quot;, i, nr); i&lt;-i+1; { &quot;underline&quot;} ## [1] &quot;underline&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\rx&quot;, i, nr); i&lt;-i+1; { &quot;radicalex&quot;} ## [1] &quot;radicalex&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\ap&quot;, i, nr); i&lt;-i+1; { &quot;similar&quot;} ## [1] &quot;similar&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\fm&quot;, i, nr); i&lt;-i+1; { &quot;minute&quot;} ## [1] &quot;minute&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\&lt;=&quot;, i, nr); i&lt;-i+1; { &quot;lessequal&quot;} ## [1] &quot;lessequal&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\f/&quot;, i, nr); i&lt;-i+1; { &quot;fraction&quot;} ## [1] &quot;fraction&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\if&quot;, i, nr); i&lt;-i+1; { &quot;infinity&quot;} ## [1] &quot;infinity&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\Fn&quot;, i, nr); i&lt;-i+1; { &quot;florin&quot;} ## [1] &quot;florin&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\CL&quot;, i, nr); i&lt;-i+1; { &quot;club&quot;} ## [1] &quot;club&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\DI&quot;, i, nr); i&lt;-i+1; { &quot;diamond&quot;} ## [1] &quot;diamond&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\HE&quot;, i, nr); i&lt;-i+1; { &quot;heart&quot;} ## [1] &quot;heart&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\SP&quot;, i, nr); i&lt;-i+1; { &quot;spade&quot;} ## [1] &quot;spade&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\&lt;&gt;&quot;, i, nr); i&lt;-i+1; { &quot;arrowboth&quot;} ## [1] &quot;arrowboth&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\&lt;-&quot;, i, nr); i&lt;-i+1; { &quot;arrowleft&quot;} ## [1] &quot;arrowleft&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\ua&quot;, i, nr); i&lt;-i+1; { &quot;arrowup&quot;} ## [1] &quot;arrowup&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\-&gt;&quot;, i, nr); i&lt;-i+1; { &quot;arrowright&quot;} ## [1] &quot;arrowright&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\da&quot;, i, nr); i&lt;-i+1; { &quot;arrowdown&quot;} ## [1] &quot;arrowdown&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\de&quot;, i, nr); i&lt;-i+1; { &quot;degree&quot;} ## [1] &quot;degree&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\+-&quot;, i, nr); i&lt;-i+1; { &quot;plusminus&quot;} ## [1] &quot;plusminus&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\sd&quot;, i, nr); i&lt;-i+1; { &quot;second&quot;} ## [1] &quot;second&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\&gt;=&quot;, i, nr); i&lt;-i+1; { &quot;greaterequal&quot;} ## [1] &quot;greaterequal&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\mu&quot;, i, nr); i&lt;-i+1; { &quot;multiply&quot;} ## [1] &quot;multiply&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\pt&quot;, i, nr); i&lt;-i+1; { &quot;proportional&quot;} ## [1] &quot;proportional&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\pd&quot;, i, nr); i&lt;-i+1; { &quot;partialdiff&quot;} ## [1] &quot;partialdiff&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\bu&quot;, i, nr); i&lt;-i+1; { &quot;bullet&quot;} ## [1] &quot;bullet&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\di&quot;, i, nr); i&lt;-i+1; { &quot;divide&quot;} ## [1] &quot;divide&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\!=&quot;, i, nr); i&lt;-i+1; { &quot;notequal&quot;} ## [1] &quot;notequal&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\==&quot;, i, nr); i&lt;-i+1; { &quot;equivalence&quot;} ## [1] &quot;equivalence&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\~~&quot;, i, nr); i&lt;-i+1; { &quot;approxequal&quot;} ## [1] &quot;approxequal&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\..&quot;, i, nr); i&lt;-i+1; { &quot;ellipsis&quot;} ## [1] &quot;ellipsis&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\an&quot;, i, nr); i&lt;-i+1; { &quot;arrowhorizex&quot;} ## [1] &quot;arrowhorizex&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\CR&quot;, i, nr); i&lt;-i+1; { &quot;carriagereturn&quot;} ## [1] &quot;carriagereturn&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\Ah&quot;, i, nr); i&lt;-i+1; { &quot;aleph&quot;} ## [1] &quot;aleph&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\Im&quot;, i, nr); i&lt;-i+1; { &quot;Ifraktur&quot;} ## [1] &quot;Ifraktur&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\Re&quot;, i, nr); i&lt;-i+1; { &quot;Rfraktur&quot;} ## [1] &quot;Rfraktur&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\wp&quot;, i, nr); i&lt;-i+1; { &quot;weierstrass&quot;} ## [1] &quot;weierstrass&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\c*&quot;, i, nr); i&lt;-i+1; { &quot;circlemultiply&quot;} ## [1] &quot;circlemultiply&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\c+&quot;, i, nr); i&lt;-i+1; { &quot;circleplus&quot;} ## [1] &quot;circleplus&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\es&quot;, i, nr); i&lt;-i+1; { &quot;emptyset&quot;} ## [1] &quot;emptyset&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\ca&quot;, i, nr); i&lt;-i+1; { &quot;cap&quot;} ## [1] &quot;cap&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\cu&quot;, i, nr); i&lt;-i+1; { &quot;cup&quot;} ## [1] &quot;cup&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\SS&quot;, i, nr); i&lt;-i+1; { &quot;superset&quot;} ## [1] &quot;superset&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\ip&quot;, i, nr); i&lt;-i+1; { &quot;reflexsuperset&quot;} ## [1] &quot;reflexsuperset&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\n&lt;&quot;, i, nr); i&lt;-i+1; { &quot;notsubset&quot;} ## [1] &quot;notsubset&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\SB&quot;, i, nr); i&lt;-i+1; { &quot;subset&quot;} ## [1] &quot;subset&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\ib&quot;, i, nr); i&lt;-i+1; { &quot;reflexsubset&quot;} ## [1] &quot;reflexsubset&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\mo&quot;, i, nr); i&lt;-i+1; { &quot;element&quot;} ## [1] &quot;element&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\nm&quot;, i, nr); i&lt;-i+1; { &quot;notelement&quot;} ## [1] &quot;notelement&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\/_&quot;, i, nr); i&lt;-i+1; { &quot;angle&quot;} ## [1] &quot;angle&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\gr&quot;, i, nr); i&lt;-i+1; { &quot;nabla&quot;} ## [1] &quot;nabla&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\rg&quot;, i, nr); i&lt;-i+1; { &quot;registerserif&quot;} ## [1] &quot;registerserif&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\co&quot;, i, nr); i&lt;-i+1; { &quot;copyrightserif&quot;} ## [1] &quot;copyrightserif&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\tm&quot;, i, nr); i&lt;-i+1; { &quot;trademarkserif&quot;} ## [1] &quot;trademarkserif&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\PR&quot;, i, nr); i&lt;-i+1; { &quot;product&quot;} ## [1] &quot;product&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\sr&quot;, i, nr); i&lt;-i+1; { &quot;radical&quot;} ## [1] &quot;radical&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\md&quot;, i, nr); i&lt;-i+1; { &quot;dotmath&quot;} ## [1] &quot;dotmath&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\no&quot;, i, nr); i&lt;-i+1; { &quot;logicalnot&quot;} ## [1] &quot;logicalnot&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\AN&quot;, i, nr); i&lt;-i+1; { &quot;logicaland&quot;} ## [1] &quot;logicaland&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\OR&quot;, i, nr); i&lt;-i+1; { &quot;logicalor&quot;} ## [1] &quot;logicalor&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\hA&quot;, i, nr); i&lt;-i+1; { &quot;arrowdblboth&quot;} ## [1] &quot;arrowdblboth&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\lA&quot;, i, nr); i&lt;-i+1; { &quot;arrowdblleft&quot;} ## [1] &quot;arrowdblleft&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\uA&quot;, i, nr); i&lt;-i+1; { &quot;arrowdblup&quot;} ## [1] &quot;arrowdblup&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\rA&quot;, i, nr); i&lt;-i+1; { &quot;arrowdblright&quot;} ## [1] &quot;arrowdblright&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\dA&quot;, i, nr); i&lt;-i+1; { &quot;arrowdbldown&quot;} ## [1] &quot;arrowdbldown&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\lz&quot;, i, nr); i&lt;-i+1; { &quot;lozenge&quot;} ## [1] &quot;lozenge&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\la&quot;, i, nr); i&lt;-i+1; { &quot;angleleft&quot;} ## [1] &quot;angleleft&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\RG&quot;, i, nr); i&lt;-i+1; { &quot;registersans&quot;} ## [1] &quot;registersans&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\CO&quot;, i, nr); i&lt;-i+1; { &quot;copyrightsans&quot;} ## [1] &quot;copyrightsans&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\TM&quot;, i, nr); i&lt;-i+1; { &quot;trademarksans&quot;} ## [1] &quot;trademarksans&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\SU&quot;, i, nr); i&lt;-i+1; { &quot;summation&quot;} ## [1] &quot;summation&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\lc&quot;, i, nr); i&lt;-i+1; { &quot;bracketlefttp&quot;} ## [1] &quot;bracketlefttp&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\lf&quot;, i, nr); i&lt;-i+1; { &quot;bracketleftbt&quot;} ## [1] &quot;bracketleftbt&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\ra&quot;, i, nr); i&lt;-i+1; { &quot;angleright&quot;} ## [1] &quot;angleright&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\is&quot;, i, nr); i&lt;-i+1; { &quot;integral&quot;} ## [1] &quot;integral&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\rc&quot;, i, nr); i&lt;-i+1; { &quot;bracketrighttp&quot;} ## [1] &quot;bracketrighttp&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\rf&quot;, i, nr); i&lt;-i+1; { &quot;bracketrightbt&quot;} ## [1] &quot;bracketrightbt&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\~=&quot;, i, nr); i&lt;-i+1; { &quot;congruent&quot;} ## [1] &quot;congruent&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\pr&quot;, i, nr); i&lt;-i+1; { &quot;minute&quot;} ## [1] &quot;minute&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\in&quot;, i, nr); i&lt;-i+1; { &quot;infinity&quot;} ## [1] &quot;infinity&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\n=&quot;, i, nr); i&lt;-i+1; { &quot;notequal&quot;} ## [1] &quot;notequal&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\dl&quot;, i, nr); i&lt;-i+1; { &quot;nabla&quot;} ## [1] &quot;nabla&quot; ## ## &gt; nr &lt;- 25 ## ## &gt; nc &lt;- 4 ## ## &gt; make.table(nr, nc) ## ## &gt; i &lt;- 0 ## ## &gt; draw.title(&quot;ISO Latin-1 Escape Sequences&quot;, i, nr, nc) ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\r!&quot;, i, nr); i&lt;-i+1; { &quot;exclamdown&quot;} ## [1] &quot;exclamdown&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\ct&quot;, i, nr); i&lt;-i+1; { &quot;cent&quot;} ## [1] &quot;cent&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\Po&quot;, i, nr); i&lt;-i+1; { &quot;sterling&quot;} ## [1] &quot;sterling&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\Ye&quot;, i, nr); i&lt;-i+1; { &quot;yen&quot;} ## [1] &quot;yen&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\bb&quot;, i, nr); i&lt;-i+1; { &quot;brokenbar&quot;} ## [1] &quot;brokenbar&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\sc&quot;, i, nr); i&lt;-i+1; { &quot;section&quot;} ## [1] &quot;section&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\ad&quot;, i, nr); i&lt;-i+1; { &quot;dieresis&quot;} ## [1] &quot;dieresis&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\co&quot;, i, nr); i&lt;-i+1; { &quot;copyright&quot;} ## [1] &quot;copyright&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\Of&quot;, i, nr); i&lt;-i+1; { &quot;ordfeminine&quot;} ## [1] &quot;ordfeminine&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\no&quot;, i, nr); i&lt;-i+1; { &quot;logicalnot&quot;} ## [1] &quot;logicalnot&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\hy&quot;, i, nr); i&lt;-i+1; { &quot;hyphen&quot;} ## [1] &quot;hyphen&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\rg&quot;, i, nr); i&lt;-i+1; { &quot;registered&quot;} ## [1] &quot;registered&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\a-&quot;, i, nr); i&lt;-i+1; { &quot;macron&quot;} ## [1] &quot;macron&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\de&quot;, i, nr); i&lt;-i+1; { &quot;degree&quot;} ## [1] &quot;degree&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\+-&quot;, i, nr); i&lt;-i+1; { &quot;plusminus&quot;} ## [1] &quot;plusminus&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\S2&quot;, i, nr); i&lt;-i+1; { &quot;twosuperior&quot;} ## [1] &quot;twosuperior&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\S3&quot;, i, nr); i&lt;-i+1; { &quot;threesuperior&quot;} ## [1] &quot;threesuperior&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\aa&quot;, i, nr); i&lt;-i+1; { &quot;acute&quot;} ## [1] &quot;acute&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\*m&quot;, i, nr); i&lt;-i+1; { &quot;mu&quot;} ## [1] &quot;mu&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\md&quot;, i, nr); i&lt;-i+1; { &quot;periodcentered&quot;} ## [1] &quot;periodcentered&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\S1&quot;, i, nr); i&lt;-i+1; { &quot;onesuperior&quot;} ## [1] &quot;onesuperior&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\Om&quot;, i, nr); i&lt;-i+1; { &quot;ordmasculine&quot;} ## [1] &quot;ordmasculine&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\14&quot;, i, nr); i&lt;-i+1; { &quot;onequarter&quot;} ## [1] &quot;onequarter&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\12&quot;, i, nr); i&lt;-i+1; { &quot;onehalf&quot;} ## [1] &quot;onehalf&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\34&quot;, i, nr); i&lt;-i+1; { &quot;threequarters&quot;} ## [1] &quot;threequarters&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\r?&quot;, i, nr); i&lt;-i+1; { &quot;questiondown&quot;} ## [1] &quot;questiondown&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\`A&quot;, i, nr); i&lt;-i+1; { &quot;Agrave&quot;} ## [1] &quot;Agrave&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\&#39;A&quot;, i, nr); i&lt;-i+1; { &quot;Aacute&quot;} ## [1] &quot;Aacute&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\^A&quot;, i, nr); i&lt;-i+1; { &quot;Acircumflex&quot;} ## [1] &quot;Acircumflex&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\~A&quot;, i, nr); i&lt;-i+1; { &quot;Atilde&quot;} ## [1] &quot;Atilde&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\:A&quot;, i, nr); i&lt;-i+1; { &quot;Adieresis&quot;} ## [1] &quot;Adieresis&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\oA&quot;, i, nr); i&lt;-i+1; { &quot;Aring&quot;} ## [1] &quot;Aring&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\AE&quot;, i, nr); i&lt;-i+1; { &quot;AE&quot;} ## [1] &quot;AE&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\,C&quot;, i, nr); i&lt;-i+1; { &quot;Ccedilla&quot;} ## [1] &quot;Ccedilla&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\`E&quot;, i, nr); i&lt;-i+1; { &quot;Egrave&quot;} ## [1] &quot;Egrave&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\&#39;E&quot;, i, nr); i&lt;-i+1; { &quot;Eacute&quot;} ## [1] &quot;Eacute&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\^E&quot;, i, nr); i&lt;-i+1; { &quot;Ecircumflex&quot;} ## [1] &quot;Ecircumflex&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\:E&quot;, i, nr); i&lt;-i+1; { &quot;Edieresis&quot;} ## [1] &quot;Edieresis&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\`I&quot;, i, nr); i&lt;-i+1; { &quot;Igrave&quot;} ## [1] &quot;Igrave&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\&#39;I&quot;, i, nr); i&lt;-i+1; { &quot;Iacute&quot;} ## [1] &quot;Iacute&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\^I&quot;, i, nr); i&lt;-i+1; { &quot;Icircumflex&quot;} ## [1] &quot;Icircumflex&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\:I&quot;, i, nr); i&lt;-i+1; { &quot;Idieresis&quot;} ## [1] &quot;Idieresis&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\~N&quot;, i, nr); i&lt;-i+1; { &quot;Ntilde&quot;} ## [1] &quot;Ntilde&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\`O&quot;, i, nr); i&lt;-i+1; { &quot;Ograve&quot;} ## [1] &quot;Ograve&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\&#39;O&quot;, i, nr); i&lt;-i+1; { &quot;Oacute&quot;} ## [1] &quot;Oacute&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\^O&quot;, i, nr); i&lt;-i+1; { &quot;Ocircumflex&quot;} ## [1] &quot;Ocircumflex&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\~O&quot;, i, nr); i&lt;-i+1; { &quot;Otilde&quot;} ## [1] &quot;Otilde&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\:O&quot;, i, nr); i&lt;-i+1; { &quot;Odieresis&quot;} ## [1] &quot;Odieresis&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\mu&quot;, i, nr); i&lt;-i+1; { &quot;multiply&quot;} ## [1] &quot;multiply&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\/O&quot;, i, nr); i&lt;-i+1; { &quot;Oslash&quot;} ## [1] &quot;Oslash&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\`U&quot;, i, nr); i&lt;-i+1; { &quot;Ugrave&quot;} ## [1] &quot;Ugrave&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\&#39;U&quot;, i, nr); i&lt;-i+1; { &quot;Uacute&quot;} ## [1] &quot;Uacute&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\^U&quot;, i, nr); i&lt;-i+1; { &quot;Ucircumflex&quot;} ## [1] &quot;Ucircumflex&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\:U&quot;, i, nr); i&lt;-i+1; { &quot;Udieresis&quot;} ## [1] &quot;Udieresis&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\&#39;Y&quot;, i, nr); i&lt;-i+1; { &quot;Yacute&quot;} ## [1] &quot;Yacute&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\ss&quot;, i, nr); i&lt;-i+1; { &quot;germandbls&quot;} # WRONG! ## [1] &quot;germandbls&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\`a&quot;, i, nr); i&lt;-i+1; { &quot;agrave&quot;} ## [1] &quot;agrave&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\&#39;a&quot;, i, nr); i&lt;-i+1; { &quot;aacute&quot;} ## [1] &quot;aacute&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\^a&quot;, i, nr); i&lt;-i+1; { &quot;acircumflex&quot;} ## [1] &quot;acircumflex&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\~a&quot;, i, nr); i&lt;-i+1; { &quot;atilde&quot;} ## [1] &quot;atilde&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\:a&quot;, i, nr); i&lt;-i+1; { &quot;adieresis&quot;} ## [1] &quot;adieresis&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\oa&quot;, i, nr); i&lt;-i+1; { &quot;aring&quot;} ## [1] &quot;aring&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\ae&quot;, i, nr); i&lt;-i+1; { &quot;ae&quot;} ## [1] &quot;ae&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\,c&quot;, i, nr); i&lt;-i+1; { &quot;ccedilla&quot;} ## [1] &quot;ccedilla&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\`e&quot;, i, nr); i&lt;-i+1; { &quot;egrave&quot;} ## [1] &quot;egrave&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\&#39;e&quot;, i, nr); i&lt;-i+1; { &quot;eacute&quot;} ## [1] &quot;eacute&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\^e&quot;, i, nr); i&lt;-i+1; { &quot;ecircumflex&quot;} ## [1] &quot;ecircumflex&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\:e&quot;, i, nr); i&lt;-i+1; { &quot;edieresis&quot;} ## [1] &quot;edieresis&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\`i&quot;, i, nr); i&lt;-i+1; { &quot;igrave&quot;} ## [1] &quot;igrave&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\&#39;i&quot;, i, nr); i&lt;-i+1; { &quot;iacute&quot;} ## [1] &quot;iacute&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\^i&quot;, i, nr); i&lt;-i+1; { &quot;icircumflex&quot;} ## [1] &quot;icircumflex&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\:i&quot;, i, nr); i&lt;-i+1; { &quot;idieresis&quot;} ## [1] &quot;idieresis&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\~n&quot;, i, nr); i&lt;-i+1; { &quot;ntilde&quot;} ## [1] &quot;ntilde&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\`o&quot;, i, nr); i&lt;-i+1; { &quot;ograve&quot;} ## [1] &quot;ograve&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\&#39;o&quot;, i, nr); i&lt;-i+1; { &quot;oacute&quot;} ## [1] &quot;oacute&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\^o&quot;, i, nr); i&lt;-i+1; { &quot;ocircumflex&quot;} ## [1] &quot;ocircumflex&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\~o&quot;, i, nr); i&lt;-i+1; { &quot;otilde&quot;} ## [1] &quot;otilde&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\:o&quot;, i, nr); i&lt;-i+1; { &quot;odieresis&quot;} ## [1] &quot;odieresis&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\di&quot;, i, nr); i&lt;-i+1; { &quot;divide&quot;} ## [1] &quot;divide&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\/o&quot;, i, nr); i&lt;-i+1; { &quot;oslash&quot;} ## [1] &quot;oslash&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\`u&quot;, i, nr); i&lt;-i+1; { &quot;ugrave&quot;} ## [1] &quot;ugrave&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\&#39;u&quot;, i, nr); i&lt;-i+1; { &quot;uacute&quot;} ## [1] &quot;uacute&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\^u&quot;, i, nr); i&lt;-i+1; { &quot;ucircumflex&quot;} ## [1] &quot;ucircumflex&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\:u&quot;, i, nr); i&lt;-i+1; { &quot;udieresis&quot;} ## [1] &quot;udieresis&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\&#39;y&quot;, i, nr); i&lt;-i+1; { &quot;yacute&quot;} ## [1] &quot;yacute&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\:y&quot;, i, nr); i&lt;-i+1; { &quot;ydieresis&quot;} ## [1] &quot;ydieresis&quot; ## ## &gt; nr &lt;- 25 ## ## &gt; nc &lt;- 2 ## ## &gt; make.table(nr, nc) ## ## &gt; i &lt;- 0 ## ## &gt; draw.title(&quot;Special Escape Sequences&quot;, i, nr, nc) ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\AR&quot;, i, nr); i&lt;-i+1; { &quot;aries&quot;} ## [1] &quot;aries&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\TA&quot;, i, nr); i&lt;-i+1; { &quot;taurus&quot;} ## [1] &quot;taurus&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\GE&quot;, i, nr); i&lt;-i+1; { &quot;gemini&quot;} ## [1] &quot;gemini&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\CA&quot;, i, nr); i&lt;-i+1; { &quot;cancer&quot;} ## [1] &quot;cancer&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\LE&quot;, i, nr); i&lt;-i+1; { &quot;leo&quot;} ## [1] &quot;leo&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\VI&quot;, i, nr); i&lt;-i+1; { &quot;virgo&quot;} ## [1] &quot;virgo&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\LI&quot;, i, nr); i&lt;-i+1; { &quot;libra&quot;} ## [1] &quot;libra&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\SC&quot;, i, nr); i&lt;-i+1; { &quot;scorpio&quot;} ## [1] &quot;scorpio&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\SG&quot;, i, nr); i&lt;-i+1; { &quot;sagittarius&quot;} ## [1] &quot;sagittarius&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\CP&quot;, i, nr); i&lt;-i+1; { &quot;capricornus&quot;} ## [1] &quot;capricornus&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\AQ&quot;, i, nr); i&lt;-i+1; { &quot;aquarius&quot;} ## [1] &quot;aquarius&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\PI&quot;, i, nr); i&lt;-i+1; { &quot;pisces&quot;} ## [1] &quot;pisces&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\~-&quot;, i, nr); i&lt;-i+1; { &quot;modifiedcongruent&quot;} ## [1] &quot;modifiedcongruent&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\hb&quot;, i, nr); i&lt;-i+1; { &quot;hbar&quot;} ## [1] &quot;hbar&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\IB&quot;, i, nr); i&lt;-i+1; { &quot;interbang&quot;} ## [1] &quot;interbang&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\Lb&quot;, i, nr); i&lt;-i+1; { &quot;lambdabar&quot;} ## [1] &quot;lambdabar&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\UD&quot;, i, nr); i&lt;-i+1; { &quot;undefined&quot;} ## [1] &quot;undefined&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\SO&quot;, i, nr); i&lt;-i+1; { &quot;sun&quot;} ## [1] &quot;sun&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\ME&quot;, i, nr); i&lt;-i+1; { &quot;mercury&quot;} ## [1] &quot;mercury&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\VE&quot;, i, nr); i&lt;-i+1; { &quot;venus&quot;} ## [1] &quot;venus&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\EA&quot;, i, nr); i&lt;-i+1; { &quot;earth&quot;} ## [1] &quot;earth&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\MA&quot;, i, nr); i&lt;-i+1; { &quot;mars&quot;} ## [1] &quot;mars&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\JU&quot;, i, nr); i&lt;-i+1; { &quot;jupiter&quot;} ## [1] &quot;jupiter&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\SA&quot;, i, nr); i&lt;-i+1; { &quot;saturn&quot;} ## [1] &quot;saturn&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\UR&quot;, i, nr); i&lt;-i+1; { &quot;uranus&quot;} ## [1] &quot;uranus&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\NE&quot;, i, nr); i&lt;-i+1; { &quot;neptune&quot;} ## [1] &quot;neptune&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\PL&quot;, i, nr); i&lt;-i+1; { &quot;pluto&quot;} ## [1] &quot;pluto&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\LU&quot;, i, nr); i&lt;-i+1; { &quot;moon&quot;} ## [1] &quot;moon&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\CT&quot;, i, nr); i&lt;-i+1; { &quot;comet&quot;} ## [1] &quot;comet&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\ST&quot;, i, nr); i&lt;-i+1; { &quot;star&quot;} ## [1] &quot;star&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\AS&quot;, i, nr); i&lt;-i+1; { &quot;ascendingnode&quot;} ## [1] &quot;ascendingnode&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\DE&quot;, i, nr); i&lt;-i+1; { &quot;descendingnode&quot;} ## [1] &quot;descendingnode&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\s-&quot;, i, nr); i&lt;-i+1; { &quot;s1&quot;} ## [1] &quot;s1&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\dg&quot;, i, nr); i&lt;-i+1; { &quot;dagger&quot;} ## [1] &quot;dagger&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\dd&quot;, i, nr); i&lt;-i+1; { &quot;daggerdbl&quot;} ## [1] &quot;daggerdbl&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\li&quot;, i, nr); i&lt;-i+1; { &quot;line integral&quot;} ## [1] &quot;line integral&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\-+&quot;, i, nr); i&lt;-i+1; { &quot;minusplus&quot;} ## [1] &quot;minusplus&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\||&quot;, i, nr); i&lt;-i+1; { &quot;parallel&quot;} ## [1] &quot;parallel&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\rn&quot;, i, nr); i&lt;-i+1; { &quot;overscore&quot;} ## [1] &quot;overscore&quot; ## ## &gt; draw.vf.cell(tf, fi, &quot;\\\\ul&quot;, i, nr); i&lt;-i+1; { &quot;underscore&quot;} ## [1] &quot;underscore&quot; ## ## &gt; nr &lt;- 25 ## ## &gt; nc &lt;- 3 ## ## &gt; make.table(nr, nc) ## ## &gt; ## octal escape codes, as decimals ## &gt; code &lt;- c(300:307,310:317,320:327,330:337,340:347,350:357,360:367,370:377, ## + 243,263) ## ## &gt; ocode &lt;- 64*(code%/%100) + 8*(code%/%10)%%10 + code%%10 ## ## &gt; string &lt;- rawToChar(as.raw(ocode), multiple=TRUE) ## ## &gt; draw.title(&quot;Cyrillic Octal Codes&quot;, i = 0, nr ,nc) ## ## &gt; for (i in 1:66) ## + draw.vf.cell(tf, &quot;cyrillic&quot;, string[i], i-1, nr, ## + raw.string=paste(&quot;\\\\&quot;, as.character(code[i]), sep=&quot;&quot;)) ## ## &gt; nr &lt;- 25 ## ## &gt; nc &lt;- 3 ## ## &gt; make.table(nr, nc) ## ## &gt; code &lt;- c(252,254,256,262:269,275,278:281,284,745,746,750:768,796:802, ## + 804:807,809,814:828,830:834,840:844) ## ## &gt; draw.title(&quot;Raw Hershey Escape Sequences&quot;, i=0, nr, nc) ## ## &gt; for (i in 1:75) ## + draw.vf.cell(tf, fi, paste(&quot;\\\\#H&quot;,formatC(code[i],wid=4,flag=&quot;0&quot;),sep=&quot;&quot;), ## + i-1, nr) ## ## &gt; make.table(nr, nc) ## ## &gt; code &lt;- c(845:847,850:856,860:874,899:909,2296:2299,2318:2332,2367:2382, ## + 4014,4109) ## ## &gt; draw.title(&quot;More Raw Hershey Escape Sequences&quot;, i=0, nr, nc) ## ## &gt; for (i in 1:73) ## + draw.vf.cell(tf, fi, paste(&quot;\\\\#H&quot;,formatC(code[i],wid=4,flag=&quot;0&quot;),sep=&quot;&quot;), ## + i-1, nr) ## ## &gt; par(oldpar) Plotting other symbols: In the most general way, Unicode characters can be plotted as text. The code is passed in hexadecimal, long integer, with a negative sign. Here is a quarter note (Unicode: 266a) using plot() plot(0.5,0.5, pch=-0x266aL, cex=5, xlab=&quot;&quot;, ylab=&quot;&quot;) However, rendering varies across platforms since it depends on unicode support. It is safer to use the inbuilt Hershey vector fonts. 14.8 Drawing on plots abline() segments() lines() arrows() … but to get a filled arrow use polygon() Example: dividing a plot into 60° regions, centred on a point. A general approach to “lines” on a plot is provided by segments(). However in this special case one can use abline(). We have to take care though that the aspect ratio for the plot is exactly 1 - otherwise our angles are not right. Therefore we need to set the asp parameter for plots. For a general sketch * we plot the frame a bit larger, don’t draw axes * draw the ablines * draw two arrows to symbolize the coordinate axes p &lt;- c(4, 2) plot(p[1], p[2], xlim=c(-0.5,10.5), ylim=c(-0.5,10.5), xlab=&quot;&quot;, ylab=&quot;&quot;, axes=FALSE, asp=1.0) abline(h=p[2], lty=2) # horizontal abline(p[2] - (p[1]*tan(pi/3)), tan(pi/3), lty=2) # intercept, slope abline(p[2] + (p[1]*tan(pi/3)), -tan(pi/3), lty=2) # intercept, slope arrows(0, 0, 10, 0, length=0.1) # length of arrow arrows(0, 0, 0, 10, length=0.1) curves() rect() polygon() More: see the Index of functions for the graphics package 14.9 Special packages Packages in the standard distribution: use with library(“package”) graphics grid lattice Packages that can be downloaded from CRAN: use with install.packages(“package”), then library(“package”) hexbin ggplot2 Packages that can be downloaded from BioConductor * prada: if (!requireNamespace(&quot;prada&quot;, quietly = TRUE)){ #install.packages(&quot;BiocManager&quot;) BiocManager::install(&quot;prada&quot;,ask = FALSE, force=TRUE) } ## &#39;getOption(&quot;repos&quot;)&#39; replaces Bioconductor standard repositories, see ## &#39;help(&quot;repositories&quot;, package = &quot;BiocManager&quot;)&#39; for details. ## Replacement repositories: ## CRAN: https://p3m.dev/cran/__linux__/jammy/latest ## Bioconductor version 3.19 (BiocManager 1.30.25), R 4.4.1 (2024-06-14) ## Installing package(s) &#39;prada&#39; ## Warning: package &#39;prada&#39; is not available for Bioconductor version &#39;3.19&#39; ## ## A version of this package for your version of R might be available elsewhere, ## see the ideas at ## https://cran.r-project.org/doc/manuals/r-patched/R-admin.html#Installing-packages ## Installation paths not writeable, unable to update packages ## path: /usr/local/lib/R/library ## packages: ## boot, class, cluster, foreign, KernSmooth, MASS, Matrix, nlme, nnet, ## spatial, survival Try: n &lt;- 1000 x &lt;- rnorm(n) y &lt;- x^3 * 0.25 + rnorm(n, sd=0.75) # smoothed scatterplot with outliers smoothScatter(x,y, nrpoints=200, pch=20, cex=0.5, col=&quot;#6633BB55&quot;) # density adapted colours plot (x, y, col=densCols(x,y), pch=19, cex=1.5) 14.10 Self-evaluation 14.11 Further reading, links and resources If in doubt, ask! If anything about this learning unit is not clear to you, do not proceed blindly but ask for clarification. Post your question on the course mailing list: others are likely to have similar problems. Or send an email to your instructor. Author: Boris Steipe boris.steipe@utoronto.ca Created: 2017-08-05 Modified: 2018-05-05 Version: 1.0.1 Version history: 1.0.1 Maintenance 1.0 Completed to first live version 0.1 Material collected from previous tutorial 14.11.1 Updated Revision history Revision Author Date Message 5152496 Ruth Isserlin 2019-12-25 Fixed issue with task numbering because of a remove all elements call in the 2nd chapter fab47ae Ruth Isserlin 2019-12-24 initial check in of R basics book 14.11.2 Footnotes: "],["r-code-style.html", "Chapter 15 R Coding Style 15.1 Overview 15.2 General 15.3 Layout 15.4 Design and granularity 15.5 Headers 15.6 Parentheses and Braces 15.7 Spaces 15.8 Names 15.9 Conditionals 15.10 Indent Style 15.11 Indentation of long function declarations 15.12 Loops 15.13 Functions 15.14 Efficiency 15.15 [END] 15.16 Self-evaluation 15.17 Further reading, links and resources 15.18 The ABC RStudio Project 15.19 Task 28 15.20 Self-evaluation 15.21 Further reading, links and resources", " Chapter 15 R Coding Style (R coding style; software development) 15.1 Overview 15.1.1 Abstract: Now that you have encountered some concepts of R programming, how do you write good R code? 15.1.2 Objectives: This unit will: introduce tried and proven principles of writing expressive and maintainable R code. 15.1.3 Outcomes: After working through this unit you: can identify poor practice in formatting R code; know better; begin incorporating these principles into your own practice. 15.1.4 Deliverables: Time management: Before you begin, estimate how long it will take you to complete this unit. Then, record in your course journal: the number of hours you estimated, the number of hours you worked on the unit, and the amount of time that passed between start and completion of this unit. Journal: Document your progress in your Course Journal. Some tasks may ask you to include specific items in your journal. Don’t overlook these. Insights: If you find something particularly noteworthy about this unit, make a note in your insights! page. 15.1.5 Prerequisites RPR-Plotting (Introduction to R Plots) What do we even mean by “good” R code? … Warning: Coding style is a volatile topic. Friendships have been renounced, eternal vows of marriage have been dissolved, stock-options have been lost, all over a disagreement about the One True Brace Style, or whether fetchSequenceFromPDB()is a good function name or not. I am laying out coding rules below that reflect a few years of experience. They work for me, they may not work for you. However: If you are taking one of my workshops, I recommend you to follow these rules: I write this way, and we will find it easier to communicate if you do too. If you are collaborating on a software project, these rules embody the standard across the project, and I will not check-in code that deviates. Here, consistency is key; but if you think you have a better approach, you only need to convince me and we will change the rule and apply it throughout the codebase19. *If you are taking one of my courses, you may lose marks if you do not adhere to these standards. Of course, following rules must not be done blindly – we are training future collaborators, not parrots – but you need to write in the spirit of the one rule we all agree on: Well written code helps the reader to understand the intent. 15.2 General One of the goals of the coding style expressed below is that it should be easy to read for people for whom R is not the first language, or even the language of choice. There are many things that R-purists might do differently, however those probably are not well suited for a research collaboration in which people speak python, C++, javascript and R all at the same time. It should always be your goal to code as clearly and explicitly as possible. R has many complex idioms, and since it is a functional language that can generally insert functions anywhere into expressions, it is possible to write very terse, expressive code. Use this with discretion. Pace yourself, and make sure your reader can follow your flow of thought. You should aim for a generic coding style that can easily be translated to other languages if necessary, and easily understood by others whose background is in another language. And resist being crafty: more often than not the poor soul who will be confused by a particularly witty use of the language will be you, yourself, half a year later. There is an astute observation by Brian Kernighan that applies completely: “Debugging is twice as hard as writing the code in the first place. Therefore, if you write the code as cleverly as possible, you are, by definition, not smart enough to debug it.” Never sacrifice being explicit for saving on keystrokes. Code is read much more often than it is written! Use lots of comments. Don’t describe what the code does, but explain why you wrote it that way. Indent comment “#”-characters to align with the expressions in a block. Use only &lt;- for assignment, not = …but do use = when passing values into the arguments of functions. Define global variables at the beginning of the code, use all caps variable names (MAXWIDTH) for such parameters. Never have “magic numbers” appear in your code. If such variables are meant to be truly global use options() to set them. Always use for (i in seq(along=x)) {…} rather than for (i in 1:length(x)) {…} because if x == NULL the loop is executed once, with an undefined variable. Don’t use attach(). Avoid importing functions wholesale from packages with library(). Rather use the ::() syntax to make it clear which function you mean20. That’s what package namespaces are for in the first place. Bad: library(igraph) ... ... clu &lt;- components(g) Good: clu &lt;- igraph::components(g) Don’t change the global state We do understand why our functions should not have side-effects (other than the explicit intended effects of printing, plotting, or writing files). But there are subtle ways to change the global state that we need to remember - and avoid. Here’s an obvious one: Don’t use &lt;&lt;- (global assignment) except in very unusual cases. Actually never. Less obvious is: Don’t use set.seed() in functions. set.seed() changes the state of the Random Number Generator (RNG), which is part of Rs global state. If this state is changed inside a function, it might result in vastly smaller space of random numbers than you would expect. Even resetting the RNG is not a good idea: a repeatable script might require the RNG to be in a defined state and if your function does set.seed(NULL), your enclosing script is no longer repeatable. But of course, we need to be able to compute simulations repeatably. The only acceptable idiom is something like: mySim &lt;- function(N) { ... # do something random N times return(result) } set.seed(112358) # set RNG seed for repeatable randomness x &lt;- mySim(N) set.seed(NULL) # reset the RNG Then you can comment out the lines, or change them to a different seed, or reset the RNG with set.seed(NULL) - everything is explicit. 15.3 Layout Limit yourself to 80 characters per line. Don’t use semicolons to write more than one expression on a line. 15.4 Design and granularity Don’t repeat code. Use functions instead. Don’t repeat code. If you feel the urge to type code more than once, that’s how you know you should break up the code into functions. Don’t repeat code. I’m repeating this for emphasis. One of the general principles of writing clear, maintainable code is collocation. This means that information items that can affect each other should be viewable on the same screen. Spolski makes a great argument for this, together with a few excellent examples; he also makes a case for a special kind of prefix notation for variable and function names that has a lot of merit. If the code for a function does not fit on approxiamtaley one printed page, you should probably break it up further. if your loops or conditionals are nested more than three levels deep, you should rethink the logic. Actually three is already a lot. Unless you are working on 3D-objects. 15.5 Headers Give your script files headers that state purpose, author, date and version information, and note bugs and issues. Give your functions headers that describe purpose, parameters (including required datatypes), and return values. Callers should be able to work with the function without having to read the code. In RNotebooks make use of “#” to define heading and sub-headings 15.6 Parentheses and Braces In mathematical expressions, always use parentheses to define priority explicitly. Never rely on implicit operator priority. (( 1 + 2 ) / 3 ) * 4 Always use braces {}, even if you write single-line if statements and loops. 15.7 Spaces if and for are language keywords, not functions. Separate the following parenthesis from the keyword with a space. Good: if (silent) { ... Bad: if(silent) { ... Always separate operators and arguments with spaces.[Separating operators with spaces is especially important for the assignment operator &lt;-. Consider this: myPreciousData &lt; -2 returns a vector of TRUE and FALSE, depending on whether the values in myPreciousData are less than -2. But myPreciousData&lt;-2 overwrites every single element with the number 2! I’m not even making this up - happened to a student in a workshop I taught.][The = sign is a bit of a special case. When I write e.g. a plot statement, or construct a dataframe, I prefer not to use spaces if the expression ends up all on one line, but to use spaces when the arguments are on separate lines.] Never separate function names and their following parentheses with spaces. Always use a space after a comma, and never before a comma. Except in subsetting expressions, where we don’t want the comma to hide against the bracket. Good: print(1 / 3, digits = 10) if (! id %in% IDs) { ...&#39; expressionProfiles[ , 1:3] Bad: print (1 / 3 ,digits=10) if (!id %in% IDs) { ... expressionProfiles[, 1:3] 15.8 Names There are only two hard things in Computer Science: cache invalidation and naming things. Phil Karlton21 Use informative and specific filenames for code sources; give them the extension .R Periods have a syntactic meaning in object-oriented classes. I consider their use in normal variables names wrong, even though this is not a syntax error and many R library functions have such names (e.g. Sys.time() and other system calls.) Create names so that related variables or functions are alphabetically sorted together, code autocomplete will be more useful. Use the concise camelCaseStyle for variable names, don’t use the confusing.dot.style or the rambling pothole_style[But nevert hesitate to make exceptions if this makes your code more legible.][This is not a random opinion but based on that it’s easier to keep within the 80-character line limit. Also see the linked article]. Don’t abbreviate argument names when calling functions. You can, but you shouldn’t. Never reassign reserved words22. Don’t use c as a variable name since c() is a function. Don’t call your data frames df since df() is a function.23 Name length should be commensurate with the scope of a variable. Short names for local scope. More explicit names for global scope. I often write global parameters in ALL CAPS: MAXWIDTH if they are defined at the top of a code module. Specific naming conventions I like: isValid, hasNeighbour … Boolean variables findRange(), getLimits() … simple function names (verbs!) initializeTable() … not initTab() Use plurals to good advantage. node … for one element; nodes … for more elements - you can then write code like: for (node in nodes) { … nPoints … for number-of iPoints … for indices-of-points isError … don’t use isNotError: avoid double negation 15.9 Conditionals This may be controversial. The code block in an if () {…} statement is evaluated if is TRUE. But what if we use a boolean variable in the condition? Should we write: if (&lt;boolean variable&gt;) { ... or if (&lt;boolean variable&gt; == TRUE) { ... It depends. Remember - the goal is to make your code as explicit and readable as possible. If our variable is e.g. a, then … if (a) { ... … is not good. Better write … if (a == TRUE) { ... … and treat this as any other condition that needs to be evaluated. However - if you have given this a meaningful variable name in the first place, something like … if (recordIsValid) { ... … is great, whereas … if (recordIsValid == TRUE) { ... … is something that feels oddly self-contradictory. So best practice here depends on context. Myself, I more often than not end up write if (something-something-that-is-boolean == TRUE) …, (and that’s not because I don’t understand how conditionals work). Make the FALSE behaviour explicit. Always use an else at the end of a conditional to define what your code does if the condition is not TRUE. Otherwise your reader will wonder whether your code covers all cases. What if your code should do nothing in the FALSE case? Make that explicit: if (a &gt; b) { tmp &lt;- b b &lt;- a a &lt;- tmp } else { ; } Instead of the lone semicolon you could also write NULL, or invisible(NULL). 15.10 Indent Style No need for much discussion. Follow the One True Bracing Style and we will all be happy. If you don’t immediately see why: read about indent style here. Opening brace on the same line as the function or control declaration; closing brace aligned with the declaration; braces mandatory even if there is only one statement to execute. Sample: if (length(x) &gt; 1) { perm &lt;- sample(x) } else if (length(x) &gt; 0) { perm &lt;- x } else { perm &lt;- NULL } 15.11 Indentation of long function declarations Use spaces to align repeating parts of code, so errors become easier to spot. 15.12 Loops Pre-allocate your result objects to have the correct size if at all possible. Growing objects dynamically with c(), cbind(), or rbind() is much, much slower. Use seq_along(), not length() to compute the range of index variables. If the object you are iterating over has length zero (i.e. it is NULL, like e.g. the result of a grep() operation if the pattern was not found) then using … for (idx in 1:length(myVector)) { ... … will result in an iteration range of 1:0 since length(NULL) is zero, and the loop will be executed twice even though it should not have been. The correct and safe way to iterate is … for (idx in seq_along(myVector)) { ... … which will not execute since seq_along(NULL) is NULL. 15.13 Functions Explicitly assign values to crucial function arguments, even if you think you know that that value is the language default. For example … sort(x) … sorts in increasing order, smallest first. But even though … sort(x, decreasing = FALSE) … does the same thing, the expression explicitly tells the reader what it is going to do. And that’s good. Always explicitly return values from functions, never rely on the implicit behaviour that returns the last expression. This is not superfluous, it is explicit. If there is nothing to return because the function is invoked for its side effects of writing a file or plotting a graph, write it into your code that nothing will be returned. This prevents you from accidentally returning the result of last expression anyway (as the language does by default), or the reader might think you forgot something. The idiom is: return(invisible(NULL)) In general, return only from the end of the function, not from multiple places. 15.14 Efficiency If possible, do not grow data structures dynamically, but create the whole structure with “empty” values, then assign values to its elements. This is much faster. # This is really bad: system.time({ N &lt;- 100000 v &lt;- numeric() for (i in 1:N) { v &lt;- c(v, sqrt(i)) } }) ## user system elapsed ## 13.786 0.000 13.785 # Even only writing directly to new elements is much, much better: system.time({ N &lt;- 100000 v &lt;- numeric() for (i in 1:N) { v[i] &lt;- sqrt(i) } }) ## user system elapsed ## 0.027 0.000 0.027 # That&#39;s abaout as fast as doing the same thing with a vapply() function. # The fastest way is to preallocate memory, it actually comes close to the # vectorized operation: system.time({ N &lt;- 100000 v &lt;- numeric(N) for (i in seq_along(v)) { v[i] &lt;- sqrt(i) } }) ## user system elapsed ## 0.006 0.000 0.006 # Using a vectorized operation is the fastest approach overall and the # method of choice: system.time({ v &lt;- sqrt(1:100000) }) ## user system elapsed ## 0.001 0.000 0.001 Don’t buy into the “apply good, for-loop bad” nonsense. Especially not if you need speed: a well-written for-loop will outperform an apply() statement, which internally uses a for-loop anyway. The reason we often use apply() is because we are following a functional programming idiom, not because there is something magical and exalted about the apply() function. It’s usually a bit subtle which idiom is “better” at any given time. 15.15 [END] Always end your code with an # [END] comment. This way you can be sure it was copied or saved completely and nothig has been inadvertently omitted. This is important in teamwork. If even ONE team member does not adhere to this, it invalidates the efforts of EVERYONE. 15.16 Self-evaluation 15.17 Further reading, links and resources Google’s R Style Guide Jenny Bryan has very useful comments on how style supports coding XKCD on Code Quality R source code itself is largely based on the GNU coding standards Tim Ottinger on Naming Joel Spolski on collocation If in doubt, ask! If anything about this learning unit is not clear to you, do not proceed blindly but ask for clarification. Post your question on the course mailing list: others are likely to have similar problems. Or send an email to your instructor. Author: Boris Steipe boris.steipe@utoronto.ca Created: 2017-08-05 Modified: 2019-04-12 Version: 1.1.1 Version history: 1.1.1 Maintenance 1.1 Add: Dont change the global state; Avoid library() 1.0.1 Maintenance 1.0 Completed to first live version 0.1 Material collected from previous tutorial 15.17.1 Updated Revision history Revision Author Date Message 5152496 Ruth Isserlin 2019-12-25 Fixed issue with task numbering because of a remove all elements call in the 2nd chapter fab47ae Ruth Isserlin 2019-12-24 initial check in of R basics book 15.17.2 Footnotes: #Introduction to R {#r-intro} (Introduction to R) ##Overview ### Abstract: This page collects the learning units for an introduction to R. 15.17.3 Objectives: … 15.17.4 Outcomes: … 15.17.5 Deliverables: No separate deliverables: This unit collects other units and has no deliverables on its own. 15.17.6 Prerequisites: This unit builds on material covered in the following prerequisite units: RPR-Coding_style (R Coding Style) This is a “milestone unit”. Its purpose is merely to collect a number of preparatory units into a single, common prerequisite. It has no contents of its own; you are expected to be familiar and competent with all preparatory material at this point. 15.18 The ABC RStudio Project R-scripts and other resources for the learning units of this course are collected in an RStudio project. This makes it easy to update and distribute code. I push update material to the GitHub repository of the project for any unit, all you need to do is to pull the updated project to receive all updates and new files on your computer. Version control is really useful for this. However, there is an issue that you need to be aware of. If you create your own, local files and then commit them, git will complain that it would be overwriting such local material. As long as you don’t commit your files then all should be fine. This means you’ll need to do your own “versioning” by saving your own scripts under a different name from time to time. Once again: in this context: saving your own files is fine; committing your own files to version control will cause problems; changes you make to course material files and save under the same filename (like adding comments and notes) will not persist, these changes will be overwritten with the next update. You need to “Save As…” with a new filename (for example, prefix the original name with “my”). 15.19 Task 28 Open RStudio and create a New Project… cloned from a git version control directory. The repository URL is https://github.com/hyginn/ABC-units. Create this in the same way as you did for the R-tutorial. As requested on the console, type init(). This will create a file called .myProfile.R and ask you for your UofT eMail address and Student ID. You need to enter the correct values because other scripts will assume that these variables exist and are valid. Work through the task: “Local script” in the RPR-Introduction.R script. 15.20 Self-evaluation Understanding the setup Imagine you made a typo when you entered your eMail address and now the file .myProfile.R contains a mistake. How do you fix this?24 15.21 Further reading, links and resources If in doubt, ask! If anything about this learning unit is not clear to you, do not proceed blindly but ask for clarification. Post your question on the course mailing list: others are likely to have similar problems. Or send an email to your instructor. Author: Boris Steipe boris.steipe@utoronto.ca Created: 2017-08-05 Modified: 2017-08-05 Version: 1.0 Version history: 1.0 Completed to first live version. 0.1 First stub 15.21.1 Updated Revision history Revision Author Date Message 5152496 Ruth Isserlin 2019-12-25 Fixed issue with task numbering because of a remove all elements call in the 2nd chapter fab47ae Ruth Isserlin 2019-12-24 initial check in of R basics book 15.21.2 Footnotes: “What Is a Container?” n.d. Docker. https://www.docker.com/resources/what-container. and when you click on the arrow to the left, this will take you back to where you came from↩︎ Proportional fonts are for elegant document layout. Monospaced fonts are needed to properly align characters in columns. For code and sequences, we always use monospaced font.↩︎ [1] means: the following is the first (often only) element of a vector.↩︎ A “wrapper” program uses another program’s functionality in its own context. RStudio is a wrapper for R since it does not duplicate R’s functions, it runs the actual R in the background.↩︎ For example C:Documentswould be interpreted as C:Documentsew because is the linebreak character. Even though that’s actually the path name on Windows, in an R command you have to write C:Documents/new↩︎ Projects that I create for teaching are configured to use this option by default, thus once the project is loaded, the Working Directory should already be correctly set.↩︎ Actually, the first script that runs is Rprofile.site which is found on Linux and Windows machines in the C:\\Program Files\\R\\R-{version}\\etc directory. But not on Macs.↩︎ Operating systems commonly hide files whose name starts with a period “.” from normal directory listings. All files however are displayed in RStudio’s File pane. Nevertheless, it is useful to know how to view such files by default. On Macs, you can configure the Finder to show you such “hidden files” by default. To do this: (i) Open a terminal window; (ii) Type: $defaults write com.apple.Finder AppleShowAllFiles YES (iii) Restart the Finder by accessing Force quit (under the Apple menu), selecting the Finder and clicking Relaunch. (iV) If you ever want to revert this, just do the same thing but set the default to NO instead.↩︎ We use a predictive mental contents-model when we type - something like an inbuilt autocorrect-suggestion mechanism; thus if you type something unfamiliar or surprising (e.g. a subtle detail of syntax), you will notice and be able to figure out the issue. Pasting code is a merely mechanical activity.↩︎ A GUI is a Graphical User Interface, it has windows and menu items, as opposed to a “command line interface”.↩︎ lastNum &lt; 6 | lastNum &gt; 10↩︎ lastNum &gt;= 10 &amp; lastNum &lt; 20↩︎ ((((9/7) - ((((9/7) * 10) %/% 1 )/10)) * 100) %/% 1 )^(1/3) == 2↩︎ We call these “variables” because of what function they perform in our code, they actually are R “objects”.↩︎ and this means [, &lt;columns&lt;, ] is correct.↩︎ That’s assuming the worst case in that the attacker needs to know the pattern with which the password is formed, i.e. the number of characters and the alphabet that we chose from. But note that there is an even worse case: if the attacker had access to our code and the seed to our random number generator. If you start the random number generator e.g. with a new seed that is generated from Sys.time(), the possible space of seeds can be devastatingly small. But even if a seed is set explicitly with the set.seed() function, the seed is a 32-bit integer (check this with .Machine$integer.max) and thus can take only a bit more than 4 X 10^9 values, six orders of magnitude less than the 10^15 password complexity we thought we had! It turns out that the code may be a much greater vulnerability than the password itself. Keep that in mind. Keep it secret. Keep it safe.↩︎ The terms parameter and argument have similar but distinct meanings. A parameter is an item that appears in the function definition, an argument is the actual value that is passed into the function.↩︎ countDown &lt;- function(n) {start &lt;- n countdown &lt;- start txt &lt;- as.character(start) while (countdown &gt; 0) { countdown &lt;- countdown - 1 txt &lt;- c(txt, countdown) } txt &lt;- c(txt,“Lift Off!”) return(txt)} countDown(7)↩︎ I’m serious: I have reformatted major pieces of code more than once after learning of a better approach, and if that creates better code it is very satisfying.↩︎ It is happening more and more frequently that functions in different packages we load have the same name. Then our code’s behaviour will depend on the order in which the libraries were loaded. Evil.↩︎ For a complementary perspective, see here.↩︎ In my opinion, base R uses far too many function names that would be useful for variables. But we’re not going to change that. So I often just prefix my variable names with my- or this-, eg myDf, thisLength etc.↩︎ Here are more names that may seem attractive as variable names but that are in fact functions in the base R package and thus may cause confusion: all(), args(), attr(), beta(), body(), col(), date(), det(), diag(), diff(), dim(), dir(), dump(), eigen(), file(), files(), gamma(), kappa(), length(), list(), load(), log(), max(), mean(), min(), open(), q(), raw(), row(), sample(), seq(), sub(), summary(), table(), type(), url(), vector(), and version(). I’m sure you get the idea - composite names of the type proposed above in CamelCase are usually safe.↩︎ .myProfile.R is itself a file in the local working directory. Simply open it with the RStudio editor, fix the error, and save. Then type source(“.myProfile.R”) into the console to overwrite the old (wrong) definition with the corrected one.↩︎ I’m serious: I have reformatted major pieces of code more than once after learning of a better approach, and if that creates better code it is very satisfying.↩︎ It is happening more and more frequently that functions in different packages we load have the same name. Then our code’s behaviour will depend on the order in which the libraries were loaded. Evil.↩︎ For a complementary perspective, see here.↩︎ In my opinion, base R uses far too many function names that would be useful for variables. But we’re not going to change that. So I often just prefix my variable names with my- or this-, eg myDf, thisLength etc.↩︎ Here are more names that may seem attractive as variable names but that are in fact functions in the base R package and thus may cause confusion: all(), args(), attr(), beta(), body(), col(), date(), det(), diag(), diff(), dim(), dir(), dump(), eigen(), file(), files(), gamma(), kappa(), length(), list(), load(), log(), max(), mean(), min(), open(), q(), raw(), row(), sample(), seq(), sub(), summary(), table(), type(), url(), vector(), and version(). I’m sure you get the idea - composite names of the type proposed above in CamelCase are usually safe.↩︎ .myProfile.R is itself a file in the local working directory. Simply open it with the RStudio editor, fix the error, and save. Then type source(“.myProfile.R”) into the console to overwrite the old (wrong) definition with the corrected one.↩︎ "]]
